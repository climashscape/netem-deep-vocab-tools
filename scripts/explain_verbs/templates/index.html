<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#e0e5ec">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>NETEM</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="static/manifest.json">
    <!-- Tailwind CSS (Local) -->
    <script src="static/lib/tailwind.min.js"></script>
    <!-- Marked for Markdown rendering (Local) -->
    <script src="static/lib/marked.min.js"></script>
    <!-- Font Awesome (Local) -->
    <link rel="stylesheet" href="static/lib/font-awesome/css/all.min.css">
    
    <!-- Dexie.js for IndexedDB (Local) -->
    <script src="static/lib/dexie.min.js"></script>
    
    <!-- Local API Logic -->
    <script src="static/js/db.js"></script>
    <script src="static/js/ebbinghaus.js"></script>
    <script src="static/js/llm.js"></script>
    <!-- Inline Data for Android compatibility -->
    <script src="static/js/data_full_list.js" defer></script>
    <script src="static/js/data_legacy.js" defer></script>
    <script src="static/js/local_api.js" defer></script>
    
    <script>
        // Override LocalAPI.init in Dev Mode to use real backend fetch
        // This is injected ONLY in the Dev Mode template
        window.addEventListener('DOMContentLoaded', () => {
            if (window.LocalAPI) {
                // In dev mode, we want LocalAPI to pass through requests to the real backend
                // instead of trying to handle them locally with IndexedDB/JSON.
                // However, for some things (like offline capability simulation), we might want mixed mode.
                // For now, let's keep it simple: Dev mode uses real backend for /api/explain
                
                // We don't need to do much here because local_api.js already checks for fetchProxy
                // But we can set a flag to indicate we are in DEV mode
                window.IS_DEV_MODE = True;
            }
        });
    </script>

    <style>
        /* Safe Area Support */
        :root {
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }

        /* Exam-style Serif Font globally */
        html, body, button, input, select, textarea {
            font-family: 'Times New Roman', Times, 'Georgia', serif;
            letter-spacing: 0.01em;
        }

        /* Global Long Press/Selection Disable - STRICTER */
        * {
            -webkit-tap-highlight-color: transparent !important;
        }
        
        /* Apply user-select: none to most elements but NOT inputs */
        body, div, span, p, h1, h2, h3, h4, h5, h6, img, button, a, i, label, li, ul, nav, header, footer {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* Allow selection only on inputs */
        input, textarea {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
            -webkit-touch-callout: default !important;
            pointer-events: auto !important;
            touch-action: manipulation !important; /* Allow tap/pan but block zoom */
        }

        html, body {
            scrollbar-width: none;
            -ms-overflow-style: none;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Lock main body scroll, handle in containers */
            -webkit-user-drag: none;   /* Safari/Chrome */
            overscroll-behavior-y: none; /* Prevent pull-to-refresh on body */
        }

        /* Re-enable selection and long press for inputs and textareas */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            -webkit-touch-callout: default;
        }

        /* Prevent image drag/long press */
        img {
            pointer-events: none; /* Disables interaction with images completely */
            -webkit-user-drag: none;
            user-select: none;
        }

        /* Optimize touch interactions */
        button, a, input, select, textarea, .neumorphic-btn, .verb-card, .nav-item {
            touch-action: manipulation; /* Improves click responsiveness, disables double-tap zoom */
        }

        /* Mobile Tap Feedback Fix - STRICTER */
        @media (hover: none) {
            /* Disable sticky hover/active states completely */
            *:hover, *:active, *:focus {
                outline: none !important;
                -webkit-tap-highlight-color: transparent !important;
            }
            
            /* Disable CSS :active completely to prevent stuck states */
            .neumorphic-btn:active, 
            .nav-item:active,
            .verb-card:active,
            button:active {
                transform: none !important; 
                background-color: inherit !important;
            }
        }

        /* Global Pressed State (JS Controlled) */
        .is-pressed {
            transform: scale(0.96) !important;
            transition: all 0.1s ease-out !important;
        }

        /* Specific Component Press Styles */
        .neumorphic-btn.is-pressed, 
        .neumorphic-btn-sm.is-pressed,
        .neumorphic-toggle-btn.is-pressed {
            box-shadow: inset 4px 4px 6px 0 rgba(163,177,198, 0.7), 
                       inset -4px -4px 6px 0 rgba(255,255,255, 0.8) !important;
            transform: translateY(1px) scale(0.98) !important;
        }

        /* Fix for nested neumorphic elements inside buttons to look pressed together */
        .neumorphic-btn.is-pressed .neumorphic {
            box-shadow: none !important;
            transform: scale(0.95) !important;
            background: transparent !important; /* Optional: blend in completely */
        }

        .chip-btn.is-pressed {
            transform: scale(0.95) !important;
            box-shadow: inset 2px 2px 4px 0 rgba(163,177,198, 0.5), 
                       inset -2px -2px 4px 0 rgba(255,255,255, 0.6) !important;
        }

        .nav-item.is-pressed {
            transform: translateY(2px) scale(0.95) !important;
            opacity: 0.7;
        }

        .verb-card.is-pressed {
            transform: scale(0.95) !important;
            box-shadow: inset 4px 4px 8px rgb(163,177,198,0.5), 
                       inset -4px -4px 8px rgba(255,255,255, 0.8) !important;
        }
        
        .card-nav-btn.is-pressed {
            box-shadow: inset 3px 3px 6px #bebebe, inset -3px -3px 6px #ffffff !important;
            transform: scale(0.9) !important;
            color: #3b82f6 !important;
        }

        /* Learning Insight Card Press State */
        .learning-insight-card.is-pressed,
        .verb-card-block.is-pressed,
        .action-card-btn.is-pressed {
            transform: scale(0.95) !important;
            transition: all 0.1s ease-out !important;
            opacity: 0.9;
            /* Optional: Add inset shadow if desired, but scale/opacity is usually enough for blocks */
        }

        /* Verb Title Color Transition - Reset on release */
        @media (hover: hover) {
            .verb-card:hover .verb-title-text {
                color: #2563eb;
            }
        }
        .verb-card.is-pressed .verb-title-text {
            color: #2563eb;
        }

        /* Ensure active state works for other buttons */
        button.is-pressed {
            opacity: 0.7;
            transform: scale(0.95) !important;
        }

        body {
            background-color: #e0e5ec;
            color: #4a5568;
            /* padding-top: env(safe-area-inset-top);  REMOVED: Causing double padding issue */
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* App Layout Containers */
        .app-shell {
            display: flex;
            flex-direction: column;
            height: 100%; /* Changed from 100vh to 100% to respect body padding */
            width: 100%;
            position: relative;
            box-sizing: border-box;
        }

        .app-content {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 80px; /* Space for bottom nav only, safe area handled by body */
            -webkit-overflow-scrolling: touch;
        }
        .app-content.no-scroll {
            overflow-y: hidden;
            padding-bottom: 0;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: var(--safe-bottom);
            left: var(--safe-left);
            right: var(--safe-right);
            height: 54px;
            background: #e0e5ec;
            box-shadow: 0 -8px 16px rgba(163,177,198,0.25);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 40;
            border-top: 1px solid rgba(255,255,255,0.4);
            box-sizing: border-box;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            color: #a0aec0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            padding: 4px 8px;
            flex: 1;
            position: relative;
        }

        .nav-item.active {
            color: #3b82f6;
        }

        .nav-item i {
            font-size: 1.15rem;
            transition: transform 0.3s ease;
        }

        .nav-item span {
            font-size: 0.65rem;
            font-weight: 800;
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .nav-item.active span {
            opacity: 1;
            letter-spacing: 0.5px;
        }

        /* Nav item indicator */
        .nav-item::after {
            content: '';
            position: absolute;
            bottom: 0;
            width: 0;
            height: 3px;
            background: #3b82f6;
            border-radius: 3px 3px 0 0;
            transition: width 0.3s ease;
        }

        .nav-item.active::after {
            width: 20px;
        }

        /* Page transition animation */
        .page-section {
            animation: slideUp 0.4s ease-out forwards;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(15px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Neumorphism Utilities */
        .neumorphic {
            background: #e0e5ec;
            box-shadow: 9px 9px 16px rgb(163,177,198,0.6), 
                       -9px -9px 16px rgba(255,255,255, 0.5);
            border-radius: 20px;
        }
        
        .neumorphic-inset {
            background: #e0e5ec;
            box-shadow: inset 6px 6px 10px 0 rgba(163,177,198, 0.7), 
                       inset -6px -6px 10px 0 rgba(255,255,255, 0.8);
            border-radius: 15px;
        }

        .neumorphic-btn {
            background: #e0e5ec;
            box-shadow: 6px 6px 10px 0 rgba(163,177,198, 0.7), 
                       -6px -6px 10px 0 rgba(255,255,255, 0.8);
            border-radius: 50px;
            transition: all 0.2s ease-in-out;
            color: #4a5568;
            cursor: pointer;
        }

        .neumorphic-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(1);
        }
        
        /* Smaller buttons for actions */
        .neumorphic-btn-sm {
            background: #e0e5ec;
            box-shadow: 3px 3px 6px 0 rgba(163,177,198, 0.7), 
                       -3px -3px 6px 0 rgba(255,255,255, 0.8);
            border-radius: 50px;
            transition: all 0.2s ease-in-out;
            color: #4a5568;
            cursor: pointer;
        }

        /* Chip Buttons for Filters */
        .chip-btn {
            background: #e0e5ec;
            box-shadow: 4px 4px 8px 0 rgba(163,177,198, 0.6), 
                       -4px -4px 8px 0 rgba(255,255,255, 0.7);
            border-radius: 12px;
            padding: 6px 10px;
            font-size: 10px;
            font-weight: 800;
            color: #718096;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255,255,255,0.3);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .chip-btn.active {
            background: #3b82f6;
            color: white;
            box-shadow: inset 3px 3px 6px 0 rgba(0,0,0,0.1),
                        0 4px 12px rgba(59,130,246,0.3);
            border-color: rgba(255,255,255,0.2);
        }

        .chip-btn.active span[id^="count-"] {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        /* Verb Grid Item */
        .verb-card {
            background: #e0e5ec;
            box-shadow: 6px 6px 12px rgb(163,177,198,0.5), 
                       -6px -6px 12px rgba(255,255,255, 0.8);
            border-radius: 24px; /* More rounded */
            transition: all 0.2s ease-out; /* Faster for JS control */
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.4);
            width: 100%;
            max-width: 160px; /* User request: reduce card size further from 200px to 160px */
            margin-left: auto;
            margin-right: auto;
        }

        .verb-image-container {
            border-bottom: 1px solid rgba(163,177,198,0.2);
        }

        .status-badge {
            font-size: 10px;
            font-weight: 800;
            padding: 4px 10px;
            border-radius: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
        }

        .index-badge {
            font-size: 10px;
            font-weight: 800;
            padding: 4px 10px;
            border-radius: 0 0 0 12px;
            background: rgba(255,255,255,0.7);
            backdrop-filter: blur(4px);
            color: #718096;
        }

        /* Strikethrough Animation */
        .strike-anim {
            position: relative;
            display: inline-block;
        }
        .strike-anim::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 0;
            height: 2px;
            background-color: #ef4444; /* Red-500 */
            transition: width 0.4s ease-out;
            pointer-events: none;
        }
        .strike-anim.active::after {
            width: 100%;
        }
        /* Removing animation (Left to Right disappearance) */
        .strike-anim.removing::after {
            left: auto;
            right: 0;
            width: 0;
        }

        /* Card Fade Out Animation */
        .card-fade-out {
            opacity: 0;
            transform: scale(0.9) !important; /* Override hover transform */
            pointer-events: none;
            transition: all 0.4s ease-in;
        }

        /* Frosted Glass Placeholder */
        .frosted-placeholder {
            background: rgba(224, 229, 236, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            border-bottom: 1px solid rgba(163,177,198,0.2);
        }

        .frosted-placeholder i {
            font-size: 24px;
            color: rgba(163, 177, 198, 0.6);
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        /* Exclude Confirmation Overlay */
        .exclude-overlay {
            position: absolute;
            inset: 0;
            background: rgba(224, 229, 236, 0.9); /* #e0e5ec with opacity */
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            border-radius: 24px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: scale(0.95);
        }
        .exclude-overlay.active {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }
        .exclude-confirm-btn {
            background: #e0e5ec;
            box-shadow: 3px 3px 6px rgba(163,177,198,0.5), 
                       -3px -3px 6px rgba(255,255,255,0.8);
            border-radius: 12px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 10px 8px;
            font-weight: 800;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.25px;
        }
        .exclude-confirm-btn:active {
            box-shadow: inset 2px 2px 4px rgba(163,177,198,0.6), 
                       inset -2px -2px 4px rgba(255,255,255,0.8);
            transform: scale(0.97);
        }
        .mastery-confirm-btn {
            background: #e0e5ec;
            box-shadow: 3px 3px 6px rgba(163,177,198,0.5), 
                       -3px -3px 6px rgba(255,255,255,0.8);
            border-radius: 12px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 10px 8px;
            font-weight: 800;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.25px;
            color: #d97706; /* orange-600 */
        }
        .exclude-cancel-area {
            position: absolute;
            top: 8px;
            right: 8px;
            color: white;
            font-size: 14px;
        }

        /* Updated Pull to Refresh Indicator */
        #pull-to-refresh {
            height: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(to bottom, rgba(224, 229, 236, 0.8), transparent);
            color: #4b5563;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            opacity: 0;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }
        #pull-to-refresh.active {
            height: 60px;
            opacity: 1;
        }
        #pull-to-refresh i {
            font-size: 12px;
            margin-right: 10px;
            color: #3b82f6;
            transition: transform 0.3s ease;
        }
        #pull-to-refresh.refreshing i {
            animation: rotate 1s linear infinite;
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        #pull-to-refresh.pulling {
            opacity: 1;
            transition: none !important;
        }
        #pull-to-refresh i {
            transition: transform 0.2s ease;
        }
        #pull-to-refresh.ready i {
            transform: rotate(180deg);
        }
        #pull-to-refresh.refreshing i {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .verb-rank {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.75rem;
            color: #a0aec0;
            font-weight: 600;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(224, 229, 236, 0.85);
            backdrop-filter: blur(5px);
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            overscroll-behavior: none; /* Prevent scroll chaining */
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            width: 95%;
            max-width: 950px;
            /* Shrink modal height slightly (more top/bottom margin) */
            height: calc(100vh - var(--safe-bottom) - 80px);
            display: flex;
            flex-direction: column;
            position: relative;
            box-sizing: border-box; /* Ensure padding doesn't push width out */
            padding-bottom: var(--safe-bottom);
        }

        /* Hide scrollbar utility */
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .hide-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Header Stats Animation */
        .stat-value {
            transition: all 0.3s ease-out;
            display: inline-block;
        }
        .stat-value.updating {
            transform: scale(1.2);
            color: #3b82f6;
        }

        /* Review Mode UI Hiding */
        #learningModal.is-review-mode #modalTitle,
        #learningModal.is-review-mode .result-card {
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }

        /* Ensure Essence Container is visible and prominent in review mode */
        #learningModal.is-review-mode #essenceContainer {
            margin-top: auto;
            margin-bottom: auto;
            transform: translateY(-20px);
        }

        /* Peek Button & Content Style */
        #learningModal.is-review-mode.peek-active #modalTitle {
            visibility: visible !important;
            opacity: 1 !important;
            transform: scale(1.02);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        #learningModal.is-review-mode.peek-active .result-card.active {
            filter: blur(0);
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
            visibility: visible;
            z-index: 50;
        }

        /* ONLY the active card should be highlighted and centered during peek */
        #learningModal.is-review-mode.peek-active .result-card.active {
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 100 !important;
            filter: blur(0);
            transform: translate(-50%, -50%) scale(1); /* No scale to keep it grounded */
            pointer-events: auto !important;
            
            /* Remove outer shadows to kill the "floating" effect */
            box-shadow: none !important;
            
            /* Grounded border style */
            border: none;
            width: 88%; /* Narrower width for better focus */
            max-width: 550px; /* Constrain width for desktop */
            height: 165%; /* Reaching further down */
            top: 82%; /* Shift down so top is near 0% and bottom is way down near buttons */
            border-radius: 20px; /* Match modal's radius perfectly */
            
            /* Solid integration with background */
            background: #e0e5ec !important; /* Identical to modal background */
            backdrop-filter: none;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #learningModal.is-review-mode .result-card {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            filter: blur(20px);
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.95);
            pointer-events: none;
            visibility: hidden;
            z-index: 5;
        }

        /* Other cards in review mode should stay hidden even when peeking */
        #learningModal.is-review-mode.peek-active .result-card:not(.active) {
            opacity: 0 !important;
            visibility: hidden !important;
        }

        /* Enhance internal spacing during peek for a clean integrated look */
        #learningModal.is-review-mode.peek-active .result-card.active .flex-1 {
            padding-left: 1.5rem !important;
            padding-right: 1.5rem !important;
            padding-top: 1rem !important;
            padding-bottom: 2rem !important; /* Space for the bottom buttons */
        }

        #learningModal.is-review-mode.peek-active .result-card.active h1,
        #learningModal.is-review-mode.peek-active .result-card.active h2,
        #learningModal.is-review-mode.peek-active .result-card.active h3,
        #learningModal.is-review-mode.peek-active .result-card.active h4 {
            padding-left: 1.5rem !important;
            padding-right: 1.5rem !important;
            padding-top: 1.5rem !important;
        }

        #learningModal.is-review-mode.peek-active .result-card.active .mx-6.border-b {
            margin-left: 1.5rem !important;
            margin-right: 1.5rem !important;
            opacity: 0.3;
        }

        /* Remove mask effect when peeking in review mode */
        #learningModal.is-review-mode .stage-container {
            transition: opacity 0.4s ease;
        }

        #learningModal.is-review-mode.peek-active .stage-container {
            -webkit-mask-image: none !important;
            mask-image: none !important;
            opacity: 1 !important; /* Must be visible to show children cards */
            z-index: 150 !important; /* Bring above essence and title (z-60) */
        }

        #learningModal.is-review-mode #essenceContainer {
            transition: all 0.4s ease;
        }

        #learningModal.is-review-mode.peek-active #essenceContainer {
            opacity: 0.15;
            pointer-events: none;
            filter: blur(8px) grayscale(100%);
            transform: translateY(0) scale(0.98);
        }

        /* Ensure Peek Button is always visible and on top when being held */
        .peek-active #reviewControls {
            z-index: 200 !important;
            opacity: 1 !important;
        }

        /* Peek Button active state (Neumorphic Inset) */
        .peek-active #peekBtn {
            box-shadow: inset 6px 6px 10px 0 rgba(163,177,198, 0.8), 
                       inset -6px -6px 10px 0 rgba(255,255,255, 0.9) !important;
            color: #3b82f6 !important;
            /* transform: translateY(2px) scale(0.98); Removed for JS control */
        }

        .peek-active #peekBtn i {
            animation: peek-pulse 1.5s infinite;
        }

        @keyframes peek-pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .success-pulse {
            animation: success-pulse 0.5s ease-out forwards;
        }
        @keyframes success-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4); }
            50% { transform: scale(1.02); box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { transform: scale(1); }
        }

        /* Carousel / Slider Styles */
        #outputContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1200px;
            overflow: visible; /* Allow shadows to bleed into header/footer */
            padding: 0;
            z-index: 10;
        }

        /* Container wrapper for outputContainer to handle relative layout */
        .stage-container {
            flex: 1;
            position: relative;
            margin: 0;
            overflow: visible; /* Let shadows breathe */
            
            /* Smooth edge fading using mask-image */
            -webkit-mask-image: linear-gradient(
                to bottom,
                transparent 0%,
                black 2%,
                black 98%,
                transparent 100%
            );
            mask-image: linear-gradient(
                to bottom,
                transparent 0%,
                black 2%,
                black 98%,
                transparent 100%
            );
        }

        .result-card {
            position: absolute;
            top: 50%; /* Centered better */
            left: 50%;
            transform: translate(-50%, -50%);
            
            background: #e0e5ec;
            border-radius: 30px;
            box-shadow: 10px 10px 20px rgb(163,177,198,0.7), 
                       -10px -10px 20px rgba(255,255,255, 0.6);
            padding: 0;
            
            width: 94%;
            max-width: 720px;
            height: 94%;
            overflow: hidden;
            
            /* Enhanced Animation */
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: center center;
            opacity: 0;
            pointer-events: none;
            
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            
            -ms-overflow-style: none;
            scrollbar-width: none;
            z-index: 5;
        }
        
        /* Active Card (Current) */
        .result-card.active {
            opacity: 1;
            z-index: 30;
            transform: translate(-50%, -50%) scale(1) rotateX(0deg);
            pointer-events: auto;
            box-shadow: 20px 20px 40px rgb(163,177,198,0.8), 
                       -20px -20px 40px rgba(255,255,255, 0.7);
        }
        
        /* Previous Card (Gone Above) */
        .result-card.prev {
            opacity: 0;
            z-index: 10;
            transform: translate(-50%, -120%) scale(0.9) rotateX(30deg);
            filter: blur(4px);
        }
        
        /* Next Card (Peeking Below) */
        .result-card.next {
            opacity: 0.8;
            z-index: 20;
            transform: translate(-50%, -46%) scale(0.95) rotateX(-5deg);
            filter: blur(1px);
            box-shadow: 5px 5px 10px rgb(163,177,198,0.5), 
                       -5px -5px 10px rgba(255,255,255, 0.4);
        }
        
        /* Next + 1 Card (Deep Waiting) */
        .result-card.next-2 {
            opacity: 0.4;
            z-index: 10;
            transform: translate(-50%, -42%) scale(0.9) rotateX(-10deg);
            filter: blur(2px);
            box-shadow: 2px 2px 5px rgb(163,177,198,0.3);
        }
        
        .result-card::-webkit-scrollbar {
            display: none;
        }
        
        /* Navigation Controls (Vertical) */
        .card-nav-btn {
            position: absolute;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e0e5ec;
            box-shadow: 5px 5px 10px #bebebe, -5px -5px 10px #ffffff;
            color: #6b7280;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 50;
            -webkit-tap-highlight-color: transparent;
        }
        .card-nav-btn:hover {
            color: #3b82f6;
            /* Disabled for JS control */
            /* transform: scale(1.1); */
        }
        .nav-up { top: 40%; transform: translateY(-50%); }
        .nav-down { top: 60%; transform: translateY(-50%); }
        
        .result-card h3 {
            border-top: 4px solid #667eea;
            width: 40px;
            height: 40px;
            -webkit-animation: spin 1s linear infinite; /* Safari */
            animation: spin 1s linear infinite;
            margin: auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tab Styles */
        .tab-btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 16px;
            font-weight: 800;
            font-size: 0.75rem;
            color: #718096;
            background: #e0e5ec;
            box-shadow: 4px 4px 8px rgb(163,177,198,0.4), 
                       -4px -4px 8px rgba(255,255,255, 0.8);
            border: 1px solid rgba(255,255,255,0.3);
            position: relative;
            padding: 8px 18px;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .tab-btn.active {
            color: #3b82f6;
            box-shadow: inset 4px 4px 8px rgb(163,177,198,0.5), 
                       inset -4px -4px 8px rgba(255,255,255, 0.8);
            border-color: rgba(59, 130, 246, 0.2);
        }

        .tab-btn-sm {
            padding: 0.4rem 0.8rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 700;
            color: #4a5568;
            background: #e0e5ec;
            box-shadow: 4px 4px 8px 0 rgba(163,177,198, 0.5), 
                       -4px -4px 8px 0 rgba(255,255,255, 0.8);
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .tab-btn-sm.active {
            color: #3b82f6;
            box-shadow: inset 3px 3px 6px rgb(163,177,198,0.5), 
                       inset -3px -3px 6px rgba(255,255,255, 0.8);
            border-color: rgba(59, 130, 246, 0.1);
        }

        .tab-btn-sm:active {
            transform: scale(0.96);
        }
        .tab-badge {
            display: none; /* Dashboard shows counts now */
        }
        .tab-btn.active .tab-badge {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
        }

        /* Global Header (Logo, Search & Stats) */
        #sticky-header {
            width: 100%;
            max-width: 56rem; /* 4xl */
            margin: 0 auto;
            left: 0;
            right: 0;
        }
        
        /* Adjust search input for compact header */
        #search-container input {
            font-size: 11px;
        }
        .filter-scroll-container {
            position: relative;
            width: 100%;
            overflow: hidden;
        }
        .filter-scroll-container::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 40px;
            background: linear-gradient(to right, transparent, #e0e5ec);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .filter-scroll-container.can-scroll-right::after {
            opacity: 1;
        }
        .filter-scroll-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 20px;
            background: linear-gradient(to left, transparent, #e0e5ec);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .filter-scroll-container.is-scrolled::before {
            opacity: 1;
        }

        /* Page Persistence: Initial State */
        .page-section {
            display: none;
        }
        .page-section:not(.hidden) {
            display: block;
        }
        
        /* Hide everything initially to prevent flash */
        body:not(.ready) .page-section,
        body:not(.ready) #sticky-header,
        body:not(.ready) .bottom-nav {
            display: none !important;
        }
    </style>
</head>
<body class="min-h-screen overflow-hidden">
    <div class="app-shell">
        <!-- Main Content Area -->
        <div class="app-content hide-scrollbar w-full max-w-4xl mx-auto overflow-x-hidden">
            <!-- English Thinking Page -->
            <section id="page-philosophy" class="page-section hidden">
                <!-- Safe Area Spacer for Mobile Status Bar -->
                <div class="h-[var(--safe-top)] md:hidden"></div>
                <div class="px-5 pt-4 pb-24 space-y-8 max-w-2xl mx-auto">
                    <!-- Hero Section -->
                    <div class="text-center space-y-4 animate-fade-in">
                        <div class="neumorphic-btn-sm w-20 h-20 flex items-center justify-center text-blue-500 mx-auto mb-6">
                            <i class="fas fa-lightbulb text-3xl"></i>
                        </div>
                        <h2 class="text-3xl font-black text-gray-700 tracking-tight">英语思维</h2>
                        <p class="text-sm font-bold text-gray-400 uppercase tracking-[0.2em]">The Core Philosophy of NETEM</p>
                    </div>

                    <!-- Philosophy Cards -->
                    <div class="grid gap-6">
                        <!-- Card 1: Dynamic Action -->
                        <div class="neumorphic p-6 space-y-4">
                            <div class="flex items-center gap-4">
                                <div class="w-12 h-12 rounded-2xl bg-blue-50 flex items-center justify-center text-blue-500 shadow-sm border border-white">
                                    <i class="fas fa-running text-xl"></i>
                                </div>
                                <h3 class="text-lg font-black text-gray-700">动作性思维</h3>
                            </div>
                            <p class="text-gray-600 leading-relaxed font-medium">
                                英语是“动作”的语言。不同于汉语注重静态描述，英语通过动词的精妙变化（时态、语态、分词）构建动态世界。
                                <span class="block mt-2 text-blue-500 font-black text-xs uppercase tracking-wider">核心：理解动作的延伸与指向。</span>
                            </p>
                        </div>

                        <!-- Card 2: Space & Logic -->
                        <div class="neumorphic p-6 space-y-4">
                            <div class="flex items-center gap-4">
                                <div class="w-12 h-12 rounded-2xl bg-indigo-50 flex items-center justify-center text-indigo-500 shadow-sm border border-white">
                                    <i class="fas fa-cubes text-xl"></i>
                                </div>
                                <h3 class="text-lg font-black text-gray-700">空间与逻辑</h3>
                            </div>
                            <p class="text-gray-600 leading-relaxed font-medium">
                                介词不仅是连接词，更是空间方位的罗盘。英语通过严密的逻辑框架（主谓宾）将复杂的思想模块化。
                                <span class="block mt-2 text-indigo-500 font-black text-xs uppercase tracking-wider">核心：建立结构化的表达模型。</span>
                            </p>
                        </div>

                        <!-- Card 3: AI Augmentation -->
                        <div class="neumorphic p-6 space-y-4">
                            <div class="flex items-center gap-4">
                                <div class="w-12 h-12 rounded-2xl bg-cyan-50 flex items-center justify-center text-cyan-500 shadow-sm border border-white">
                                    <i class="fas fa-robot text-xl"></i>
                                </div>
                                <h3 class="text-lg font-black text-gray-700">AI 辅助拆解</h3>
                            </div>
                            <p class="text-gray-600 leading-relaxed font-medium">
                                我们利用 AI 深度剖析词汇的“本质含义”，而非简单的中文翻译。通过视觉化联想与语境拆解，让单词不再是死记硬背的符号。
                                <span class="block mt-2 text-cyan-500 font-black text-xs uppercase tracking-wider">核心：从“翻译”转向“感知”。</span>
                            </p>
                        </div>
                    </div>

                    <!-- Bottom CTA -->
                    <div class="pt-8 text-center">
                        <button onclick="switchPage('learn')" class="neumorphic-btn px-10 py-4 text-blue-600 font-black text-sm uppercase tracking-[0.2em]">
                            开启感知之旅
                        </button>
                    </div>
                </div>
            </section>

            <!-- Global Header (Logo, Search & Stats) -->
        <div id="sticky-header" class="sticky top-0 z-30 bg-[#e0e5ec]/95 backdrop-blur-md px-4 py-0.5 border-b border-white/40 shadow-sm transition-all">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            
            <!-- Integrated Row: Logo & Search -->
            <div class="flex items-center justify-between gap-3 mb-0.5 min-h-[36px]">
                <!-- Logo & Title (Compact) -->
                <div id="logo-container" class="flex items-center gap-2 shrink-0">
                    <div class="neumorphic-btn-sm w-8 h-8 flex items-center justify-center text-blue-500 text-xs cursor-pointer hover:opacity-80 transition-opacity" onclick="scrollToStudyFocus()">
                        <i class="fas fa-brain"></i>
                    </div>
                    <div class="flex flex-col leading-none">
                        <h1 class="text-sm font-black text-gray-700 tracking-tight">NETEM</h1>
                        <span class="text-[9px] font-bold text-gray-400 uppercase tracking-wider">Vocab</span>
                    </div>
                </div>

                <!-- Search Container (Flexible) -->
                <div id="search-container" class="flex-1 min-w-0">
                    <div class="neumorphic-inset flex items-center px-3 py-1.5 h-8">
                        <i class="fas fa-search text-gray-400 mr-2 text-[10px]"></i>
                        <input type="text" id="searchInput" placeholder="Search..." class="bg-transparent outline-none w-full text-gray-600 font-bold text-[11px] placeholder-gray-400/70" oninput="filterVerbs()">
                    </div>
                </div>
            </div>

            <!-- Stats & Progress Bar -->
            <div id="stats-container" class="space-y-1">
                <!-- Compact Progress Bar -->
                <div class="px-1">
                    <div class="flex items-center justify-between mb-0.5">
                        <span class="text-[10px] font-black text-gray-400 uppercase tracking-widest">Mastery</span>
                        <span id="header-progress-percent" class="text-[11px] font-black text-blue-500">0%</span>
                    </div>
                    <div class="h-2 w-full bg-gray-300/30 rounded-full border border-white/40 p-0.5 overflow-hidden">
                        <div id="header-progress-bar" class="h-full bg-gradient-to-r from-blue-400 to-blue-600 rounded-full transition-all duration-700" style="width: 0%"></div>
                    </div>
                </div>

                <div class="p-1 flex justify-between items-center bg-white/40 rounded-2xl border border-white/60">
                    <!-- Total -->
                    <div class="flex items-center gap-1.5 flex-1 justify-center border-r border-gray-300/20">
                        <div class="w-3.5 h-3.5 rounded-md bg-gray-100 flex items-center justify-center text-gray-400">
                            <i class="fas fa-layer-group text-[9px]"></i>
                        </div>
                        <div class="text-left ml-0.5">
                            <p class="text-[9px] uppercase font-black text-gray-400 leading-none mb-0.5">Total</p>
                            <p id="header-count-total" class="text-[10px] font-black text-gray-700 leading-none">0</p>
                        </div>
                    </div>
                    <!-- Review -->
                    <div class="flex items-center gap-1.5 flex-1 justify-center border-r border-gray-300/20">
                        <div class="w-3.5 h-3.5 rounded-md bg-orange-50 flex items-center justify-center text-orange-400">
                            <i class="fas fa-history text-[9px]"></i>
                        </div>
                        <div class="text-left ml-0.5">
                            <p class="text-[9px] uppercase font-black text-orange-400 leading-none mb-0.5">Review</p>
                            <p id="header-count-review" class="text-[10px] font-black text-orange-500 leading-none">0</p>
                        </div>
                    </div>
                    <!-- Mastered -->
                    <div class="flex items-center gap-1.5 flex-1 justify-center border-r border-gray-300/20">
                        <div class="w-3.5 h-3.5 rounded-md bg-green-50 flex items-center justify-center text-green-400">
                            <i class="fas fa-check-double text-[9px]"></i>
                        </div>
                        <div class="text-left ml-0.5">
                            <p class="text-[9px] uppercase font-black text-green-400 leading-none mb-0.5">Mastered</p>
                            <p id="header-count-mastered" class="text-[10px] font-black text-green-600 leading-none">0</p>
                        </div>
                    </div>
                    <!-- Today -->
                    <div class="flex items-center gap-1.5 flex-1 justify-center">
                        <div class="w-3.5 h-3.5 rounded-md bg-blue-50 flex items-center justify-center text-blue-400">
                            <i class="fas fa-calendar-day text-[9px]"></i>
                        </div>
                        <div class="text-left ml-0.5">
                            <p class="text-[9px] uppercase font-black text-blue-400 leading-none mb-0.5">Today</p>
                            <p id="header-count-today" class="text-[10px] font-black text-blue-600 leading-none">0</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

            <!-- Learn Page -->
            <section id="page-learn" class="page-section hidden">
                <div id="pull-to-refresh" class="rounded-b-2xl">
                    <i class="fas fa-sync-alt"></i>
                    <span id="refresh-text">Pull to refresh batch</span>
                </div>
                
                <div class="px-4 pt-2">
                    <main id="verbsGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 pb-24">
                        <!-- Cards will be injected here -->
                    </main>
                </div>
            </section>

            <!-- Review Page -->
            <section id="page-review" class="page-section hidden">
                  <div class="sticky top-0 z-30 bg-[#e0e5ec]/95 backdrop-blur-md px-4 py-0.5 border-b border-white/40 shadow-sm">
                      <!-- Safe Area Spacer for Mobile Status Bar -->
                      <div class="h-[var(--safe-top)] md:hidden"></div>
                      
                      <div class="flex items-center justify-between min-h-[36px] mb-0.5">
                          <div class="flex items-center gap-3">
                              <h2 class="text-xl font-bold text-gray-700">Review</h2>
                          </div>
                          <!-- Tab Toggle -->
                          <div class="flex p-1 bg-gray-200/50 rounded-xl neumorphic-inset">
                              <button onclick="switchReviewTab('session')" id="btn-review-session" class="neumorphic-toggle-btn px-4 py-1.5 text-[11px] font-bold rounded-lg transition-all bg-white shadow-sm text-blue-600">Session</button>
                              <button onclick="switchReviewTab('library')" id="btn-review-library" class="neumorphic-toggle-btn px-4 py-1.5 text-[11px] font-bold rounded-lg transition-all text-gray-500">Library</button>
                          </div>
                      </div>
                      <div id="review-stats-placeholder"></div>
                  </div>
                <div class="px-4 pt-2">
                    <div id="reviewGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 pb-24">
                        <!-- Review cards will be injected here -->
                    </div>
                </div>
            </section>

            <!-- Mastery Page -->
            <section id="page-mastery" class="page-section hidden">
                  <div class="sticky top-0 z-30 bg-[#e0e5ec]/95 backdrop-blur-md px-4 py-0.5 border-b border-white/40 shadow-sm">
                      <!-- Safe Area Spacer for Mobile Status Bar -->
                      <div class="h-[var(--safe-top)] md:hidden"></div>
                      
                      <div class="flex items-center justify-between min-h-[36px] mb-0.5">
                          <h2 class="text-xl font-bold text-gray-700">Mastery</h2>
                          <button onclick="openExcludedModal()" class="neumorphic-btn w-9 h-9 flex items-center justify-center text-red-400 relative">
                              <i class="fas fa-trash-alt text-xs"></i>
                              <span id="excludedBadgeCount" class="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] font-black w-4 h-4 rounded-full flex items-center justify-center border-2 border-[#e0e5ec] hidden">0</span>
                          </button>
                      </div>
                      <div id="mastery-stats-placeholder"></div>
                  </div>
                <div class="px-4 pt-2">
                    <div id="masteryGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 pb-24">
                        <!-- Mastered cards will be injected here -->
                    </div>
                </div>
            </section>

            <!-- Me Page (Profile) -->
            <section id="page-me" class="page-section hidden">
                <!-- Safe Area Spacer for Mobile Status Bar -->
                <div class="h-[var(--safe-top)] md:hidden"></div>
                <div class="px-4 pt-1 pb-24 space-y-4 max-w-md mx-auto md:pt-8">
                    <!-- Compact Profile Header -->
                    <div class="neumorphic p-4 flex flex-col gap-3 bg-gradient-to-br from-white/40 to-blue-50/20 relative overflow-hidden">
                        <!-- Decorative Background -->
                        <div class="absolute -right-4 -top-4 w-24 h-24 bg-blue-500/5 rounded-full blur-2xl"></div>
                        <div class="absolute -left-4 -bottom-4 w-32 h-32 bg-indigo-500/5 rounded-full blur-3xl"></div>
                        
                        <div class="flex items-center gap-3 md:gap-4 relative z-10 flex-wrap sm:flex-nowrap">
                            <div class="w-12 h-12 md:w-14 md:h-14 rounded-2xl neumorphic flex items-center justify-center text-blue-500 text-lg md:text-xl shrink-0">
                                <i class="fas fa-graduation-cap"></i>
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center gap-2 mb-0.5 flex-wrap">
                                    <span class="px-1.5 py-0.5 bg-blue-500 text-[9px] md:text-[10px] font-black text-white rounded-md tracking-tighter uppercase shadow-sm shrink-0">NETEM</span>
                                    <h2 class="text-base md:text-lg font-black text-gray-700 leading-tight tracking-tight">Deep Vocab Tools</h2>
                                </div>
                                <p class="text-[10px] md:text-[11px] font-bold text-gray-400 uppercase tracking-widest leading-tight">AI-Powered Exam Preparation</p>
                            </div>
                        </div>
                        
                        <!-- Kaoyan Countdown & Rounds (Refined Centered Layout) -->
                        <div class="flex items-center justify-around max-w-md mx-auto w-full pt-4 border-t border-gray-200/40 relative z-10">
                            <div class="text-center">
                                <p class="text-[10px] md:text-xs uppercase font-black text-blue-500 mb-1 tracking-wider opacity-60">Exam Countdown</p>
                                <div class="flex items-baseline justify-center gap-1">
                                    <span id="kaoyan-countdown" class="text-2xl md:text-3xl font-black text-blue-600 leading-none">---</span>
                                    <span class="text-[10px] md:text-xs font-black text-blue-400 opacity-60">Days</span>
                                </div>
                            </div>
                            <div class="w-px h-8 md:h-10 bg-gradient-to-b from-transparent via-gray-300/40 to-transparent"></div>
                            <div class="text-center">
                                <p class="text-[10px] md:text-xs uppercase font-black text-indigo-500 mb-1 tracking-wider opacity-60">Learning Rounds</p>
                                <div class="flex items-baseline justify-center gap-1">
                                    <span id="learning-rounds" class="text-2xl md:text-3xl font-black text-indigo-600 leading-none">0.0</span>
                                    <span class="text-[10px] md:text-xs font-black text-indigo-400 opacity-60">Rnds</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Task Center (Daily Goal & Check-in) -->
                    <div class="neumorphic p-4 bg-gradient-to-br from-indigo-50/10 to-blue-50/10 space-y-5">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-tasks text-indigo-500 text-xs"></i>
                            <h3 class="font-black text-gray-700 text-xs uppercase tracking-wider">Mission Control</h3>
                        </div>

                        <!-- Daily Goal Progress (New) -->
                        <div class="px-1">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center gap-1.5">
                                    <i class="fas fa-flag-checkered text-indigo-400 text-[10px]"></i>
                                    <span class="text-[10px] font-black text-gray-400 uppercase tracking-widest">Daily Progress</span>
                                </div>
                                <span id="daily-goal-text" class="text-[10px] font-black uppercase tracking-tight text-gray-400">0/40 New | 0 Due</span>
                            </div>
                            <div class="w-full bg-gray-200/40 h-2.5 rounded-full overflow-hidden neumorphic-inset p-0.5">
                                <div id="daily-goal-progress" class="bg-gradient-to-r from-indigo-400 via-blue-500 to-cyan-400 h-full rounded-full transition-all duration-1000 shadow-[0_0_10px_rgba(99,102,241,0.2)]" style="width: 0%"></div>
                            </div>
                            <p class="text-[10px] text-gray-400 mt-1.5 font-bold uppercase tracking-tighter opacity-60 italic text-center">Complete 40 new words & clear all reviews to check-in</p>
                        </div>

                        <!-- Recitation Check-in Calendar (7-Day View) -->
                        <div class="pt-4 border-t border-gray-200/40">
                            <div class="flex items-center justify-between mb-3 px-1">
                                <div class="flex items-center gap-1.5">
                                    <i class="fas fa-calendar-check text-blue-400 text-[11px]"></i>
                                    <span class="text-[10px] font-black text-gray-400 uppercase tracking-widest">Check-in History</span>
                                </div>
                                <span id="checkin-streak" class="text-[11px] font-black text-orange-500 bg-orange-50 px-2.5 py-0.5 rounded-full border border-orange-100/50 shadow-sm uppercase tracking-tight flex items-center gap-1">
                                    <i class="fas fa-fire-alt text-[10px]"></i>
                                    <span>0 Day Streak</span>
                                </span>
                            </div>
                            <div id="checkin-calendar" class="flex justify-between gap-1.5 px-0.5">
                                <!-- Injected by updateCheckinCalendar() -->
                            </div>
                        </div>
                    </div>

                    <!-- Statistics & Progress Card -->
                    <div class="neumorphic p-4 space-y-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-chart-pie text-blue-500 text-xs"></i>
                                <h3 class="font-black text-gray-700 text-xs uppercase tracking-wider">Learning Insights</h3>
                            </div>
                            <div id="profile-progress-percent" class="text-xs font-black text-blue-500 bg-blue-50 px-2 py-0.5 rounded-full">0%</div>
                        </div>

                        <!-- Progress Bar -->
                        <div class="space-y-1.5">
                            <div class="w-full bg-gray-200 rounded-full h-2.5 neumorphic-inset overflow-hidden p-0.5">
                                <div id="profile-progress-bar" class="bg-gradient-to-r from-blue-400 to-blue-600 h-full rounded-full transition-all duration-1000 shadow-sm" style="width: 0%"></div>
                            </div>
                            <div class="flex justify-between px-1">
                                <span class="text-[11px] font-black text-gray-400 uppercase">Started</span>
                                <span class="text-[11px] font-black text-gray-400 uppercase">Mastered</span>
                            </div>
                        </div>

                        <!-- Segmented Control (Toggle) -->
                        <div class="flex p-1 bg-gray-200/50 rounded-xl neumorphic-inset">
                            <button onclick="window.globalResetPressedState(); switchMeTab('status')" id="btn-me-status" class="neumorphic-toggle-btn flex-1 py-1.5 text-[11px] font-bold rounded-lg transition-all bg-white shadow-sm text-blue-600">Review Status</button>
                            <button onclick="window.globalResetPressedState(); switchMeTab('breakdown')" id="btn-me-breakdown" class="neumorphic-toggle-btn flex-1 py-1.5 text-[11px] font-bold rounded-lg transition-all text-gray-500">POS Breakdown</button>
                        </div>

                        <!-- Dynamic Content Area -->
                        <div id="me-tab-status" class="grid grid-cols-2 gap-2 animate-fade-in">
                            <!-- Injected by updateProfileStats() -->
                        </div>
                        <div id="me-tab-breakdown" class="hidden space-y-3 animate-fade-in">
                            <!-- Injected by updateProfileStats() -->
                        </div>
                    </div>

                    <!-- Study Selection (Filters) -->
                    <div id="study-focus-section" class="neumorphic p-4 space-y-4 transition-all duration-500">
                        <div class="flex items-center gap-2">
                            <i class="fas fa-bullseye text-blue-500 text-xs"></i>
                            <h3 class="font-black text-gray-700 text-xs uppercase tracking-wider">Study Focus</h3>
                        </div>

                        <!-- POS Selection -->
                        <div class="space-y-3">
                            <p class="text-[11px] uppercase font-black text-gray-400 ml-1 tracking-[0.15em] flex items-center gap-2 opacity-80">
                                <span class="w-1.5 h-1.5 bg-blue-400 rounded-full shadow-[0_0_8px_rgba(96,165,250,0.4)]"></span>
                                Part of Speech
                            </p>
                            <div class="flex flex-wrap gap-2">
                                <button onclick="switchPos('all')" class="chip-btn active" data-pos="all">
                                    <span>All</span>
                                    <span id="count-pos-all" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full group-hover:bg-white/50 transition-colors"></span>
                                </button>
                                <button onclick="switchPos('noun')" class="chip-btn" data-pos="noun">
                                    <span>Noun</span>
                                    <span id="count-noun" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchPos('verb')" class="chip-btn" data-pos="verb">
                                    <span>Verb</span>
                                    <span id="count-verb" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchPos('noun_verb')" class="chip-btn" data-pos="noun_verb">
                                    <span>N+V</span>
                                    <span id="count-noun_verb" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchPos('adj_adv')" class="chip-btn" data-pos="adj_adv">
                                    <span>Adj/Adv</span>
                                    <span id="count-adj_adv" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchPos('prep_conj')" class="chip-btn" data-pos="prep_conj">
                                    <span>P+C</span>
                                    <span id="count-prep_conj" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchPos('other')" class="chip-btn" data-pos="other">
                                    <span>Other</span>
                                    <span id="count-other" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                            </div>
                        </div>

                        <!-- Frequency Selection -->
                        <div class="space-y-3 pt-2 border-t border-gray-100/60">
                            <p class="text-[11px] uppercase font-black text-gray-400 ml-1 tracking-[0.15em] flex items-center gap-2 opacity-80">
                                <span class="w-1.5 h-1.5 bg-indigo-400 rounded-full shadow-[0_0_8px_rgba(129,140,248,0.4)]"></span>
                                Frequency Level
                            </p>
                            <div class="flex flex-wrap gap-2">
                                <button onclick="switchFreq('all')" class="chip-btn active" data-freq="all">
                                    <span>All</span>
                                    <span id="count-freq-all" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchFreq('must')" class="chip-btn" data-freq="must">
                                    <span>Must</span>
                                    <span id="count-must" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchFreq('core')" class="chip-btn" data-freq="core">
                                    <span>Core</span>
                                    <span id="count-core" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchFreq('advanced')" class="chip-btn" data-freq="advanced">
                                    <span>Adv</span>
                                    <span id="count-advanced" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchFreq('basic')" class="chip-btn" data-freq="basic">
                                    <span>Basic</span>
                                    <span id="count-basic" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                                <button onclick="switchFreq('rare')" class="chip-btn" data-freq="rare">
                                    <span>Rare</span>
                                    <span id="count-rare" class="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded-full"></span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Action Buttons - Integrated Grid Layout -->
                    <div class="space-y-4">
                        <!-- Primary Actions: Settings & Analytics -->
                        <div class="neumorphic p-4 space-y-4 bg-gradient-to-br from-white/20 to-transparent">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-sliders-h text-blue-500 text-xs"></i>
                                <h3 class="font-black text-gray-700 text-xs uppercase tracking-wider">System &amp; Data</h3>
                            </div>

                            <div class="grid grid-cols-2 gap-3">
                                <button onclick="openSettings()" class="neumorphic-btn p-4 flex flex-col items-center gap-2 text-gray-600 bg-white/40">
                                    <div class="w-10 h-10 rounded-2xl bg-white neumorphic flex items-center justify-center text-blue-500 shadow-sm">
                                        <i class="fas fa-cog text-sm"></i>
                                    </div>
                                    <span class="text-xs font-black uppercase tracking-widest">Settings</span>
                                </button>
                                
                                <button onclick="showAnalytics()" class="neumorphic-btn p-4 flex flex-col items-center gap-2 text-gray-600 bg-white/40">
                                    <div class="w-10 h-10 rounded-2xl bg-white neumorphic flex items-center justify-center text-purple-500 shadow-sm">
                                        <i class="fas fa-chart-line text-sm"></i>
                                    </div>
                                    <span class="text-xs font-black uppercase tracking-widest">Analytics</span>
                                </button>
                            </div>
                        </div>
                            
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <!-- Bottom Nav -->
        <nav class="bottom-nav">
            <div class="nav-item" onclick="switchPage('philosophy')">
                <i class="fas fa-lightbulb"></i>
                <span>Philosophy</span>
            </div>
            <div class="nav-item active" onclick="switchPage('learn')">
                <i class="fas fa-book-open"></i>
                <span>Learn</span>
            </div>
            <div class="nav-item" onclick="switchPage('review')">
                <i class="fas fa-history"></i>
                <span>Review</span>
                <span id="nav-review-badge" class="absolute top-0.5 left-1/2 ml-2 bg-red-500 text-white text-[9px] font-black w-3.5 h-3.5 rounded-full flex items-center justify-center border border-white hidden">0</span>
            </div>
            <div class="nav-item" onclick="switchPage('mastery')">
                <i class="fas fa-trophy"></i>
                <span>Mastery</span>
            </div>
            <div class="nav-item" onclick="switchPage('me')">
                <i class="fas fa-user-circle"></i>
                <span>Me</span>
            </div>
        </nav>

    <!-- Modal for Learning -->
    <div id="learningModal" class="modal-overlay">
        <div class="modal-content relative flex flex-col bg-[#e0e5ec] rounded-[20px] shadow-2xl overflow-hidden" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <!-- Close Indicator (Mobile Friendly) - Hidden as requested -->
            <div class="w-full flex justify-center pt-2 pb-1 opacity-40 md:hidden hidden" onclick="closeModal()">
                <div class="w-12 h-1.5 bg-gray-400/40 rounded-full"></div>
            </div>
            <!-- Close Button (Absolute for better layout) - Hidden as requested -->
            <button onclick="closeModal()" class="absolute top-4 right-4 neumorphic-btn w-10 h-10 flex items-center justify-center text-red-400 hover:text-red-500 z-[100] shadow-md hidden">
                <i class="fas fa-times"></i>
            </button>

            <!-- Progress Bar Container (Global Overlay) -->
            <div id="progressContainer" class="hidden absolute inset-0 flex flex-col items-center justify-center z-[60] bg-[#e0e5ec]/95 backdrop-blur-sm transition-all duration-300">
                <div class="w-64 md:w-80 bg-gray-300 rounded-full h-4 overflow-hidden shadow-inner neumorphic-inset">
                    <div id="progressBar" class="bg-blue-500 h-full rounded-full transition-all duration-300 ease-out shadow-sm" style="width: 0%"></div>
                </div>
                <p id="progressText" class="mt-6 text-gray-600 font-bold tracking-wide animate-pulse">Initializing...</p>
            </div>

            <!-- Modal Header -->
            <div class="px-5 pt-3 pb-1 shrink-0 w-full relative z-[60] bg-[#e0e5ec]">
                <div class="flex flex-col items-start pr-12 min-w-0 w-full">
                    <div id="modalStageBadge" class="hidden px-2 py-0.5 rounded-full bg-blue-100 text-blue-600 text-[10px] font-bold border border-blue-200 shrink-0 mb-1">Stage 0</div>
                    <h2 id="modalTitle" class="text-2xl font-black text-gray-700 capitalize truncate drop-shadow-sm w-full"></h2>
                </div>
                <!-- Refresh Button -->
                <button onclick="refreshExplanation()" class="absolute top-3 right-4 w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-blue-500 active:scale-95 transition-all">
                    <i class="fas fa-sync-alt"></i>
                </button>
            </div>
            
            <!-- Content Area (The Stage) -->
            <div class="stage-container z-10">
                <div id="outputContainer" class="hide-scrollbar">
                    <!-- Cards are absolute positioned here -->
                </div>
            </div>
            
            <!-- ESSENCE CARD AREA (Sticky Bottom) -->
            <div id="essenceContainer" class="px-0 pb-4 pt-1 shrink-0 hidden z-[60] transition-all duration-500 bg-[#e0e5ec] flex justify-center">
                <!-- Essence content wrapper will have the same width constraints as cards -->
                <div id="essenceContentWrapper" class="w-[94%] max-w-[720px]">
                    <!-- Essence content will be injected here -->
                </div>
            </div>

            <!-- Ebbinghaus Review Controls -->
            <div id="reviewControls" class="px-4 pb-4 pt-2 flex justify-center gap-4 z-[60] bg-[#e0e5ec] hidden">
                <!-- Study Mode: Only "Mark as Learned" -->
                <div id="studyModeControls" class="flex gap-4">
                    <button onclick="recordReview('remembered')" class="neumorphic-btn px-8 py-3 text-blue-600 flex items-center gap-2 hover:scale-105 active:scale-95 transition-all">
                        <i class="fas fa-check-double text-xl"></i>
                        <span class="text-sm font-black uppercase tracking-widest">Mark as Learned</span>
                    </button>
                </div>
                
                <!-- Review Mode: Peek and Reset -->
                <div id="reviewModeControls" class="hidden flex gap-4 w-full max-w-xs">
                    <button id="peekBtn" 
                        onmousedown="event.stopPropagation(); drawPeekCard()"
                        onmouseup="event.stopPropagation(); document.getElementById('learningModal').classList.remove('peek-active')"
                        onmouseleave="event.stopPropagation(); document.getElementById('learningModal').classList.remove('peek-active')"
                        ontouchstart="event.stopPropagation(); drawPeekCard(); event.preventDefault();"
                        ontouchend="event.stopPropagation(); document.getElementById('learningModal').classList.remove('peek-active')"
                        class="flex-1 neumorphic-btn py-4 text-gray-500 flex flex-col items-center justify-center gap-1.5 hover:scale-[1.02] active:scale-95 transition-all duration-300">
                        <i class="fas fa-eye text-xl"></i>
                        <span class="text-[10px] font-black uppercase tracking-widest">Hold to Peek</span>
                    </button>
                    <button onclick="resetToLearn()" class="flex-1 neumorphic-btn py-3 text-red-400 flex flex-col items-center gap-1 hover:scale-105 active:scale-95 transition-all">
                        <i class="fas fa-undo text-lg"></i>
                        <span class="text-[10px] font-bold uppercase">Reset to Learn</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Reset to Learn Confirmation Modal -->
    <div id="resetModal" class="fixed inset-0 bg-black/50 z-[70] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="if(event.target === this) closeResetModal()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-sm mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <!-- Close Indicator (Mobile Friendly) - Hidden -->
            <div class="w-full flex justify-center pb-4 opacity-40 md:hidden hidden" onclick="closeResetModal()">
                <div class="w-12 h-2 bg-gray-400/40 rounded-full"></div>
            </div>
            
            <div class="flex items-center gap-3 mb-4">
                <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-red-400">
                    <i class="fas fa-undo"></i>
                </div>
                <h3 class="text-lg font-bold text-gray-700">Reset Progress</h3>
            </div>

            <p class="text-gray-600 mb-6 text-sm">
                Are you sure you want to reset "<span id="resetVerbName" class="font-bold text-blue-600"></span>"? This word will return to the initial learning state.
            </p>
            <div class="grid grid-cols-2 gap-3">
                <button onclick="closeResetModal()" class="py-3 rounded-xl neumorphic-btn text-gray-500 font-black text-xs uppercase tracking-wider">
                    Cancel
                </button>
                <button id="confirmResetBtn" class="py-3 rounded-xl neumorphic-btn text-red-500 font-black text-xs uppercase tracking-wider">
                    Reset
                </button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <!-- Confirm Modal (Specific for Refresh) -->
    <div id="refreshConfirmModal" class="fixed inset-0 bg-black/50 z-[60] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="if(event.target === this) closeRefreshConfirmModal()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-sm mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <!-- Close Indicator (Mobile Friendly) - Hidden -->
            <div class="w-full flex justify-center pb-4 opacity-40 md:hidden hidden" onclick="closeRefreshConfirmModal()">
                <div class="w-12 h-2 bg-gray-400/40 rounded-full"></div>
            </div>

            <div class="flex items-center gap-3 mb-4">
                <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-blue-500">
                    <i class="fas fa-sync-alt"></i>
                </div>
                <h3 class="text-lg font-bold text-gray-700">Confirm Refresh</h3>
            </div>

            <p class="text-gray-600 mb-6 text-sm">
                 Are you sure you want to refresh the explanation for "<span id="confirmVerb" class="font-bold text-blue-600"></span>"?
                <br><br>
                <span id="apiCheckStatus" class="text-xs flex items-center gap-2">
                    <!-- Dynamic status will be inserted here -->
                </span>
            </p>
            <div class="grid grid-cols-2 gap-3">
                <button onclick="closeRefreshConfirmModal()" class="py-3 rounded-xl neumorphic-btn text-gray-500 font-black text-xs uppercase tracking-wider">
                    Cancel
                </button>
                <button id="confirmRefreshBtn" class="py-3 rounded-xl neumorphic-btn text-blue-500 font-black text-xs uppercase tracking-wider">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- Excluded Verbs Modal -->
    <div id="excludedModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center hidden" onclick="closeExcludedModal(event)">
        <div class="bg-[#e0e5ec] w-[90%] max-w-md rounded-3xl p-6 neumorphic animate-fade-in flex flex-col max-h-[90vh]" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <!-- Close Indicator (Mobile Friendly) - Hidden -->
            <div class="w-full flex justify-center pb-4 opacity-40 md:hidden hidden" onclick="closeExcludedModal()">
                <div class="w-12 h-2 bg-gray-400/40 rounded-full"></div>
            </div>
            <div class="flex items-center justify-between mb-6">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-red-500">
                        <i class="fas fa-trash-alt"></i>
                    </div>
                    <div>
                        <h3 class="text-lg font-black text-gray-700">Excluded Verbs</h3>
                        <p class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Words you've cleared</p>
                    </div>
                </div>
                <button onclick="closeExcludedModal()" class="w-8 h-8 rounded-full neumorphic flex items-center justify-center text-gray-400 hover:text-gray-600 transition-colors hidden">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div class="neumorphic-inset p-4 rounded-2xl max-h-[60vh] overflow-y-auto hide-scrollbar mb-6">
                <div id="modalExcludedList" class="flex flex-wrap gap-2">
                    <p class="text-xs text-gray-400 italic w-full text-center py-4">No excluded verbs</p>
                </div>
            </div>

            <button onclick="saveExcludedChanges()" class="w-full py-3 rounded-xl neumorphic-btn text-blue-600 font-black text-sm uppercase tracking-wider">
                Save Changes
            </button>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="fixed inset-0 bg-black/50 z-[90] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-sm mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <div class="flex items-center gap-3 mb-4">
                <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-blue-500">
                    <i class="fas fa-question-circle"></i>
                </div>
                <h3 id="confirmTitle" class="text-lg font-black text-gray-700">Confirm</h3>
            </div>
            <p id="confirmText" class="text-gray-600 mb-6 text-sm"></p>
            <div class="grid grid-cols-2 gap-3">
                <button id="confirmCancelBtn" class="py-3 rounded-xl neumorphic-btn text-gray-400 font-black text-xs uppercase tracking-widest">
                    Cancel
                </button>
                <button id="confirmOkBtn" class="py-3 rounded-xl neumorphic-btn text-blue-600 font-black text-xs uppercase tracking-widest">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- Generic Message Modal (Success/Error) -->
    <div id="messageModal" class="fixed inset-0 bg-black/50 z-[80] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="closeMessageModal()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-sm mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <div class="flex items-center gap-3 mb-4">
                <div id="messageIcon" class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center">
                    <i class="fas fa-info-circle"></i>
                </div>
                <h3 id="messageTitle" class="text-lg font-bold text-gray-700">Notification</h3>
            </div>
            <p id="messageText" class="text-gray-600 mb-6"></p>
            <button onclick="closeMessageModal()" class="w-full py-3 rounded-xl neumorphic-btn text-blue-600 font-black text-sm uppercase tracking-wider">
                OK
            </button>
        </div>
    </div>

    <!-- Search Input Modal -->
    <div id="searchModal" class="fixed inset-0 bg-black/50 z-[100] hidden flex items-start justify-center pt-20 backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="closeSearchModal()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-md mx-4 transform -translate-y-4 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <div class="flex items-center gap-3 mb-6">
                <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-blue-500">
                    <i class="fas fa-search"></i>
                </div>
                <div>
                    <h3 class="text-lg font-black text-gray-700">Deep Search</h3>
                    <p class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Type to find words</p>
                </div>
                <button onclick="closeSearchModal()" class="ml-auto w-8 h-8 rounded-full neumorphic flex items-center justify-center text-gray-400 hidden">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="neumorphic-inset flex items-center px-4 py-3 mb-6">
                <i class="fas fa-search text-gray-400 mr-3"></i>
                <input type="text" id="modalSearchInput" placeholder="Search words..." 
                    class="bg-transparent outline-none w-full text-gray-700 font-bold text-base"
                    oninput="syncSearch(this.value)">
            </div>
            
            <button onclick="closeSearchModal()" class="w-full py-4 rounded-xl neumorphic-btn text-blue-600 font-black text-sm uppercase tracking-[0.2em]">
                Done
            </button>
        </div>
    </div>

    <!-- Clear All Data Confirmation Modal (Dual Option) -->
    <div id="clearAllModal" class="fixed inset-0 bg-black/50 z-[75] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="closeClearAllModal()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-sm mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <!-- Close Indicator (Mobile Friendly) -->
            <div class="w-full flex justify-center pb-4 opacity-40 md:hidden" onclick="closeClearAllModal()">
                <div class="w-12 h-2 bg-gray-400/40 rounded-full"></div>
            </div>

            <div class="flex items-center gap-3 mb-6">
                <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-red-500">
                    <i class="fas fa-trash-alt"></i>
                </div>
                <div>
                    <h3 class="text-lg font-black text-gray-700">Reset & Clear</h3>
                    <p class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Danger Zone</p>
                </div>
            </div>

            <div class="space-y-4 mb-6">
                <!-- Option 1: Clear Progress -->
                <button id="btn-clear-progress" disabled class="w-full p-4 rounded-2xl neumorphic flex flex-col items-start gap-1 group active:scale-[0.98] transition-all bg-white/40 opacity-50 cursor-not-allowed">
                    <div class="flex items-center gap-2">
                        <i class="fas fa-undo text-blue-500 text-xs"></i>
                        <span class="text-xs font-black text-gray-700 uppercase tracking-wider">Clear Progress Only <span class="countdown-text">(5s)</span></span>
                    </div>
                    <p class="text-[10px] text-gray-400 font-bold text-left">Resets memory stages and review plans. Keeps settings and excluded words.</p>
                </button>

                <!-- Option 2: Full Initialize -->
                <button id="btn-full-init" disabled class="w-full p-4 rounded-2xl neumorphic flex flex-col items-start gap-1 group active:scale-[0.98] transition-all bg-red-50/30 opacity-50 cursor-not-allowed">
                    <div class="flex items-center gap-2">
                        <i class="fas fa-power-off text-red-500 text-xs"></i>
                        <span class="text-xs font-black text-red-600 uppercase tracking-wider">Full Reset <span class="countdown-text">(5s)</span></span>
                    </div>
                    <p class="text-[10px] text-gray-400 font-bold text-left">Wipes all data including progress, excluded words, and settings.</p>
                </button>
            </div>

            <button onclick="closeClearAllModal()" class="w-full py-3 rounded-xl neumorphic-btn text-gray-500 font-black text-xs uppercase tracking-wider">
                Cancel
            </button>
        </div>
    </div>

    <!-- Analytics / Ebbinghaus Chart Modal -->
    <div id="analyticsModal" class="fixed inset-0 bg-black/50 z-[70] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="closeAnalytics()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-2xl mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            <!-- Close Indicator (Mobile Friendly) -->
            <div class="w-full flex justify-center pb-4 opacity-40 md:hidden" onclick="closeAnalytics()">
                <div class="w-12 h-2 bg-gray-400/40 rounded-full"></div>
            </div>
            <div class="flex items-center justify-between mb-6">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-purple-500">
                        <i class="fas fa-chart-line"></i>
                    </div>
                    <div>
                        <h3 class="text-lg font-black text-gray-700">Learning Analytics</h3>
                        <p class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Ebbinghaus Forgetting Curve</p>
                    </div>
                </div>
                <button onclick="closeAnalytics()" class="w-8 h-8 rounded-full neumorphic flex items-center justify-center text-gray-400 hover:text-gray-600 transition-colors md:flex hidden">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div id="ebbinghausChart" class="w-full min-h-[280px] sm:min-h-[400px] flex items-center justify-center overflow-x-auto">
                <!-- SVG Chart injected here -->
            </div>

            <div class="mt-6 pt-6 border-t border-gray-200/60 text-center">
                <p class="text-[10px] text-gray-400 font-bold uppercase tracking-widest leading-relaxed">
                    Points represent words in your current review scope.<br>
                    Higher stages indicate stronger memory consolidation.
                </p>
            </div>
        </div>
    </div>

    <!-- Import Confirmation Modal -->
    <div id="importConfirmModal" class="fixed inset-0 bg-black/50 z-[70] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300" onclick="if(event.target === this) closeImportConfirmModal()">
        <div class="bg-[#e0e5ec] rounded-2xl shadow-xl p-6 w-full max-w-sm mx-4 transform scale-95 transition-transform duration-300 border border-white/50" onclick="event.stopPropagation()">
            <!-- Safe Area Spacer for Mobile Status Bar -->
            <div class="h-[var(--safe-top)] md:hidden"></div>
            
            <div class="flex items-center gap-3 mb-4">
                <div class="w-10 h-10 rounded-xl neumorphic flex items-center justify-center text-green-500">
                    <i class="fas fa-file-import"></i>
                </div>
                <h3 class="text-lg font-bold text-gray-700">Import Data</h3>
            </div>

            <p class="text-gray-600 mb-6 text-sm">
                This will <span class="text-red-500 font-bold">OVERWRITE</span> your current progress and settings. Are you sure you want to restore from backup?
            </p>
            <div class="grid grid-cols-2 gap-3">
                <button onclick="closeImportConfirmModal()" class="py-3 rounded-xl neumorphic-btn text-gray-500 font-black text-xs uppercase tracking-wider">
                    Cancel
                </button>
                <button id="confirmImportBtn" class="py-3 rounded-xl neumorphic-btn text-green-500 font-black text-xs uppercase tracking-wider">
                    Restore
                </button>
            </div>
        </div>
    </div>

    <!-- Toast Container Removed -->

    <script>
        /**
         * 开发文档 / Development Guidelines:
         * 1. 禁用系统弹窗 (alert, confirm, prompt) - 必须使用自定义模态框实现。
         * 2. 禁用 Toast 通知 - 必须使用自定义模态框或应用内 UI 反馈。
         */

        // --- Pull to Refresh Logic ---
        let touchStartPos = 0;
        let pullDistance = 0;
        const pullThreshold = 80;
        let isRefreshing = false;
        
        // Use a function to initialize listeners after DOM is ready
        function initPullToRefresh() {
            const pullElement = document.getElementById('pull-to-refresh');
            const refreshText = document.getElementById('refresh-text');
            const scrollContainer = document.querySelector('.app-content');
            
            if (!pullElement || !scrollContainer) return;

            scrollContainer.addEventListener('touchstart', (e) => {
                if (scrollContainer.scrollTop === 0 && currentPage === 'learn') {
                    touchStartPos = e.touches[0].pageY;
                } else {
                    touchStartPos = 0;
                }
            }, { passive: true });

            scrollContainer.addEventListener('touchmove', (e) => {
                if (touchStartPos > 0 && !isRefreshing) {
                    const currentTouch = e.touches[0].pageY;
                    pullDistance = Math.max(0, currentTouch - touchStartPos);
                    
                    if (pullDistance > 0) {
                        if (e.cancelable) e.preventDefault(); // Stop native scroll
                        pullElement.classList.add('pulling');
                        pullElement.style.height = `${Math.min(pullDistance * 0.5, pullThreshold + 20)}px`;
                        
                        pullElement.style.color = '#3b82f6'; // blue-500
                    if (pullDistance * 0.5 >= pullThreshold) {
                        pullElement.classList.add('ready');
                        refreshText.innerText = 'Release to refresh';
                    } else {
                        pullElement.classList.remove('ready');
                        refreshText.innerText = 'Pull down to refresh';
                    }
                }
            }
        }, { passive: false });

        scrollContainer.addEventListener('touchend', () => {
            if (pullDistance * 0.5 >= pullThreshold && !isRefreshing) {
                performRefresh(pullElement, refreshText);
            } else {
                resetPull(pullElement, refreshText);
            }
        });
        }

        function performRefresh(pullElement, refreshText) {
            isRefreshing = true;
            pullElement.classList.remove('ready');
            pullElement.classList.add('refreshing');
            refreshText.innerText = 'Refreshing...';
            pullElement.style.height = `${pullThreshold}px`;

            // Trigger the actual refresh (random 4)
            setTimeout(() => {
                applyFilters(true); // Force generate new batch
                resetPull(pullElement, refreshText);
            }, 800);
        }

        function resetPull(pullElement, refreshText) {
            isRefreshing = false;
            pullDistance = 0;
            touchStartPos = 0;
            pullElement.style.height = '0px';
            pullElement.classList.remove('pulling', 'ready', 'refreshing');
            setTimeout(() => {
                if (refreshText) refreshText.innerText = 'Pull down to refresh';
            }, 200);
        }
        // --- End Pull to Refresh Logic ---

        const safeUpdate = (id, val) => {
            const el = document.getElementById(id);
            if (el) {
                if (el.innerText !== String(val)) {
                    // Add animation if it's a numeric value
                    if (!isNaN(val)) {
                        el.classList.add('updating');
                        setTimeout(() => el.classList.remove('updating'), 300);
                    }
                    el.innerText = val;
                }
            }
        };

        let allVerbs = [];
        let displayedVerbs = [];
        let learningStatus = {}; // Store Ebbinghaus progress
        let currentCardIndex = 0; // Track current card in modal
        
        // Auto Image Generation Queue
        let imageQueue = [];
        let isQueueProcessing = false;
        
        let currentPos = ['all'];
        let currentFreq = ['all'];
        let currentPage = null;
        let currentReviewTab = 'session'; // 'session' or 'library'
        let reviewVerbsList = []; // Track verbs shown on the review page
        let sessionReviewStats = { count: 0, remembered: 0 };
        let isReviewMode = false;
        let spellingWord = '';
        let limit = 4;
        let offset = 0;
        let isLoading = false;
        // Migration: Check for legacy settings and default to 'auto' if not set
        let analysisMode = localStorage.getItem('analysisMode') || 'auto'; 

        // Backwards compatibility migration (run once)
        if (!localStorage.getItem('analysisMode')) {
            const legacyAuto = localStorage.getItem('autoAiAnalysis');
            const legacyCache = localStorage.getItem('cacheOnlyMode');
            
            if (legacyAuto === 'false') {
                analysisMode = 'manual';
            } else if (legacyCache === 'true') {
                analysisMode = 'cache_only';
            } else {
                analysisMode = 'auto';
            }
            localStorage.setItem('analysisMode', analysisMode);
        }
        
        // --- Back Button Support for Modals ---
        let modalStack = [];
        window.addEventListener('popstate', (event) => {
            if (modalStack.length > 0) {
                const lastModalCloseFn = modalStack.pop();
                if (typeof lastModalCloseFn === 'function') {
                    // Call the close function without adding another popstate entry
                    lastModalCloseFn(true); 
                }
            }
        });

        function pushModalState(closeFn) {
            modalStack.push(closeFn);
            history.pushState({ modal: true }, "");
        }
        // --- End Back Button Support ---

        function matchesPos(v, posArray) {
            if (posArray.includes('all')) return true;
            if (posArray.includes('excluded')) return excludedVerbs.has(v['单词']);
            if (excludedVerbs.has(v['单词'])) return false; // Other tabs hide excluded

            return posArray.some(pos => {
                if (pos === 'prep_conj') return (v.pos === 'prep' || v.pos === 'prep_conj');
                if (pos === 'adj_adv') return (v.pos === 'adj' || v.pos === 'adv' || v.pos === 'adj_adv');
                if (pos === 'other') {
                    const knownPos = ['noun', 'verb', 'noun_verb', 'adj', 'adv', 'adj_adv', 'prep', 'prep_conj'];
                    return v.pos === 'other' || !knownPos.includes(v.pos);
                }
                return v.pos === pos;
            });
        }

        function matchesFreq(v, freqArray) {
            if (freqArray.includes('all')) return true;
            const verbKey = v['单词'].toLowerCase();
            const status = learningStatus[verbKey];
            
            return freqArray.some(freq => {
                if (freq === 'review') {
                    return status && status.stage > 0 && status.status !== 'mastered';
                }
                if (freq === 'mastered') {
                    return status && status.status === 'mastered';
                }
                return v.group === freq;
            });
        }

        function switchPage(pageId) {
            if (currentPage === pageId) return;
            
            // User request: Clear search content when switching pages so search is scoped to each page
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
            }

            // Update UI State
            document.querySelectorAll('.page-section').forEach(p => p.classList.add('hidden'));
            const targetPage = document.getElementById(`page-${pageId}`);
            if (targetPage) targetPage.classList.remove('hidden');
            
            // Hide sticky header components on non-learn pages
            const stickyHeader = document.getElementById('sticky-header');
            const logoContainer = document.getElementById('logo-container');
            const searchContainer = document.getElementById('search-container');
            const statsContainer = document.getElementById('stats-container');
            
            if (stickyHeader && logoContainer && searchContainer && statsContainer) {
                if (pageId === 'learn') {
                    stickyHeader.classList.remove('hidden');
                    logoContainer.classList.remove('hidden');
                    searchContainer.classList.remove('hidden');
                    // Move stats back to sticky header and ensure visible
                    stickyHeader.appendChild(statsContainer);
                    statsContainer.classList.remove('hidden');
                    // Check search width when returning to learn page
                    setTimeout(checkSearchWidth, 50);
                } else if (pageId === 'philosophy') {
                    // Philosophy page also hides the sticky header as it has its own header style
                    stickyHeader.classList.add('hidden');
                    statsContainer.classList.add('hidden');
                } else {
                    // We hide the logo and search on non-learn pages to clean up header
                    logoContainer.classList.add('hidden');
                    searchContainer.classList.add('hidden');
                    // On other pages, we hide the sticky header because it's empty
                    // but we only hide it if the stats are moved elsewhere
                    stickyHeader.classList.add('hidden');
                    
                    // Move stats to page-specific placeholder if it exists
                    const placeholder = document.getElementById(`${pageId}-stats-placeholder`);
                    if (placeholder) {
                        placeholder.appendChild(statsContainer);
                        statsContainer.classList.remove('hidden');
                    } else {
                        // Default to hiding if no placeholder exists
                        statsContainer.classList.add('hidden');
                    }
                }
            }
            
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
                // Support both onclick with single quotes and double quotes
                if (item.getAttribute('onclick')?.includes(`'${pageId}'`) || item.getAttribute('onclick')?.includes(`"${pageId}"`)) {
                    item.classList.add('active');
                }
            });
            
            currentPage = pageId;
            
            // Persist Page State
            try {
                const savedState = localStorage.getItem(STATE_KEY);
                const state = savedState ? JSON.parse(savedState) : {};
                state.currentPage = pageId;
                localStorage.setItem(STATE_KEY, JSON.stringify(state));
            } catch (e) {}
            
            // Trigger specific page logic (Defer slightly to let the page transition animation start smoothly)
            setTimeout(() => {
                if (pageId === 'review') {
                    renderReviewPage();
                } else if (pageId === 'mastery') {
                    renderMasteryPage();
                } else if (pageId === 'me') {
                    updateProfileStats();
                    // Sync Analysis Mode radio buttons
                    updateAnalysisModeUI(analysisMode);
                } else if (pageId === 'learn') {
                    // Ensure learn page is filtered correctly
                    applyFilters();
                }
            }, 50);
            
            // Scroll to top of the content area
            const appContent = document.querySelector('.app-content');
            if (appContent) {
                appContent.classList.remove('no-scroll');
                // Use immediate scroll for page switches to prevent animation conflict
                appContent.scrollTop = 0;
            }
        }

        function scrollToStudyFocus() {
            // 1. Switch to Me page
            switchPage('me');
            
            // 2. Wait for DOM update and scroll
            setTimeout(() => {
                const section = document.getElementById('study-focus-section');
                const appContent = document.querySelector('.app-content');
                
                if (section && appContent) {
                    // Calculate target scroll position to center the element
                    const elementRect = section.getBoundingClientRect();
                    const containerRect = appContent.getBoundingClientRect();
                    
                    // Center calculation: 
                    // Target Scroll Top = Current Scroll Top + (Element Top relative to Viewport - Container Top relative to Viewport) - (Container Height / 2) + (Element Height / 2)
                    // Simplified: We want the element's center to be at the container's center.
                    
                    const scrollTop = appContent.scrollTop + elementRect.top - containerRect.top - (containerRect.height / 2) + (elementRect.height / 2);
                    
                    // Smooth scroll
                    appContent.scrollTo({
                        top: scrollTop,
                        behavior: 'smooth'
                    });
                    
                    // 3. Highlight animation
                    section.classList.add('ring-4', 'ring-blue-400', 'ring-opacity-50', 'scale-[1.02]', 'transition-all', 'duration-500');
                    setTimeout(() => {
                        section.classList.remove('ring-4', 'ring-blue-400', 'ring-opacity-50', 'scale-[1.02]', 'transition-all', 'duration-500');
                    }, 1500);
                }
            }, 300); // Wait for page transition
        }

        function switchReviewTab(tab) {
            currentReviewTab = tab;
            
            // Update UI buttons
            const btnSession = document.getElementById('btn-review-session');
            const btnLibrary = document.getElementById('btn-review-library');
            
            if (tab === 'session') {
                btnSession.classList.add('bg-white', 'shadow-sm', 'text-blue-600');
                btnSession.classList.remove('text-gray-500');
                btnLibrary.classList.remove('bg-white', 'shadow-sm', 'text-blue-600');
                btnLibrary.classList.add('text-gray-500');
            } else {
                btnLibrary.classList.add('bg-white', 'shadow-sm', 'text-blue-600');
                btnLibrary.classList.remove('text-gray-500');
                btnSession.classList.remove('bg-white', 'shadow-sm', 'text-blue-600');
                btnSession.classList.add('text-gray-500');
            }
            
            renderReviewPage();
        }

        function renderReviewPage() {
            const grid = document.getElementById('reviewGrid');
            if (!grid) return;
            
            const now = new Date();
            
            // Sync counts based on current filters
            updateCounts();

            if (currentReviewTab === 'session') {
                // SESSION MODE: Show words due for review
                const query = document.getElementById('searchInput')?.value || '';
                reviewVerbsList = allVerbs.filter(v => {
                    const status = learningStatus[v['单词'].toLowerCase()];
                    if (!status) return false;
                    
                    // Excluded Logic
                    if (excludedVerbs.has(v['单词'])) return false;
                    
                    // POS Filter logic
                    if (!matchesPos(v, currentPos)) return false;

                    // Frequency Filter logic (Sync with header stats)
                    if (!matchesFreq(v, currentFreq)) return false;

                    // Search Filter
                    if (query && !v['单词'].includes(query)) return false;

                    // Include words due for review and learning words (not mastered)
                    const isDue = new Date(status.next_review) <= now;
                    return status.status !== 'mastered' && isDue;
                });
                
                // Sort: due first (by next_review time)
                reviewVerbsList.sort((a, b) => {
                    const statusA = learningStatus[a['单词'].toLowerCase()];
                    const statusB = learningStatus[b['单词'].toLowerCase()];
                    return new Date(statusA.next_review) - new Date(statusB.next_review);
                });
                
                if (reviewVerbsList.length === 0) {
                    grid.innerHTML = `
                        <div class="col-span-full py-20 text-center animate-fade-in">
                            <!-- Action Button: Analytics -->
                            <div onclick="window.globalResetPressedState(); showAnalytics()" class="action-card-btn neumorphic-btn-sm w-16 h-16 flex items-center justify-center text-blue-500 mx-auto mb-6 cursor-pointer transition-transform">
                                <i class="fas fa-book-open text-2xl"></i>
                            </div>
                            <h3 class="text-xl font-black text-gray-700 mb-2">Review Session</h3>
                            <p class="text-gray-400 font-bold text-xs mb-8">All caught up! Check back later.</p>
                        </div>`;
                    return;
                }
                
                // Don't show cards, show a Start Review button
                grid.innerHTML = `
                    <div class="col-span-full py-20 text-center animate-fade-in relative overflow-hidden">
                        <div id="review-session-init" class="transition-opacity duration-300 w-full">
                            <!-- Action Button: Analytics -->
                            <div onclick="window.globalResetPressedState(); showAnalytics()" class="action-card-btn neumorphic-btn-sm w-16 h-16 flex items-center justify-center text-blue-500 mx-auto mb-6 cursor-pointer transition-transform">
                                <i class="fas fa-bolt text-2xl"></i>
                            </div>
                            <h3 class="text-xl font-black text-gray-700 mb-2">Review Session</h3>
                            <p class="text-xs text-gray-400 font-bold uppercase tracking-wider mb-8">
                                ${reviewVerbsList.length} words are ready for review
                            </p>
                            
                            <button onclick="window.globalResetPressedState(); startReviewSession()" class="action-card-btn neumorphic-btn px-10 py-4 text-blue-600 font-black text-xs uppercase tracking-[0.2em] transition-all">
                                Start Reviewing
                            </button>
                        </div>
                    </div>`;
            } else {
                // LIBRARY MODE: Show all words currently in review (status is learning)
                const query = document.getElementById('searchInput')?.value || '';
                const learnedVerbs = allVerbs.filter(v => {
                    const status = learningStatus[v['单词'].toLowerCase()];
                    // "Reset to Learn" sets it to Stage 0, we want to see it in Library.
                    if (!status || status.status === 'mastered') return false;
                    
                    // Excluded Logic
                    if (excludedVerbs.has(v['单词'])) return false;
                    
                    // POS Filter logic
                    if (!matchesPos(v, currentPos)) return false;
                    
                    // Frequency Filter logic (Sync with header stats)
                    if (!matchesFreq(v, currentFreq)) return false;
                    
                    // Search Filter
                    if (query && !v['单词'].includes(query)) return false;
                    
                    return true;
                });

                // Sort learnedVerbs: by stage descending
                learnedVerbs.sort((a, b) => {
                    const sA = learningStatus[a['单词'].toLowerCase()];
                    const sB = learningStatus[b['单词'].toLowerCase()];
                    return sB.stage - sA.stage;
                });

                if (learnedVerbs.length === 0) {
                    grid.innerHTML = `
                        <div class="col-span-full py-20 text-center animate-fade-in">
                            <!-- Action Button: Analytics -->
                            <div onclick="window.globalResetPressedState(); showAnalytics()" class="action-card-btn neumorphic-btn-sm w-16 h-16 flex items-center justify-center text-blue-500 mx-auto mb-6 cursor-pointer transition-transform">
                                <i class="fas fa-graduation-cap text-2xl"></i>
                            </div>
                            <h3 class="text-xl font-black text-gray-700 mb-2">Library</h3>
                            <p class="text-gray-400 font-bold text-xs mb-8">No learned words yet. Start learning to see them here.</p>
                        </div>`;
                    return;
                }

                grid.innerHTML = '';
                learnedVerbs.forEach(v => {
                    // Ensure createVerbCard generates interactive blocks
                    const card = createVerbCard(v);
                    grid.appendChild(card);
                });
            }
        }

        function startReviewSession() {
            if (reviewVerbsList.length > 0) {
                // Reset session stats for a fresh start
                sessionReviewStats = { count: 0, remembered: 0 };
                // Open the first word in review mode
                openVerb(reviewVerbsList[0]['单词'], true);
            }
        }

        function renderReviewSummary() {
            const grid = document.getElementById('reviewGrid');
            if (!grid) return;
            
            grid.innerHTML = `
                <div class="col-span-full py-20 text-center animate-fade-in">
                    <!-- Action Button: Analytics -->
                    <div onclick="window.globalResetPressedState(); showAnalytics()" class="action-card-btn neumorphic-btn-sm w-16 h-16 flex items-center justify-center text-green-500 mx-auto mb-6 cursor-pointer transition-transform">
                        <i class="fas fa-trophy text-2xl"></i>
                    </div>
                    <h3 class="text-xl font-black text-gray-700 mb-2">Review Complete!</h3>
                    <p class="text-gray-400 font-bold text-xs mb-8">Session Summary</p>
                    
                    <div class="flex justify-center max-w-xs mx-auto mb-10">
                        <div class="neumorphic p-4 rounded-2xl w-32">
                            <span class="block text-lg font-black text-green-500">${sessionReviewStats.remembered}</span>
                            <span class="text-[10px] text-gray-400 font-bold uppercase">Words Learned</span>
                        </div>
                    </div>
                    
                    <button onclick="switchPage('learn')" class="neumorphic-btn px-8 py-3 text-blue-500 font-black text-xs uppercase tracking-widest">
                        Back to Library
                    </button>
                </div>`;
                
            // Reset session stats
            sessionReviewStats = { count: 0, remembered: 0 };
        }

        function renderMasteryPage() {
            const grid = document.getElementById('masteryGrid');
            if (!grid) return;
            
            const query = document.getElementById('searchInput')?.value || '';
            
            // User request: "Learn页面的 Total Review Mastered 应该和当前选择的单词库范围相吻合，review和masterey页面同样"
            // We apply the same POS filter logic here
            const masteredVerbs = allVerbs.filter(v => {
                const status = learningStatus[v['单词'].toLowerCase()];
                if (!status || status.status !== 'mastered') return false;

                // Excluded Logic
                if (excludedVerbs.has(v['单词'])) return false;
                
                // POS Filter logic
                if (!matchesPos(v, currentPos)) return false;

                // Frequency Filter logic (Sync with header stats)
                if (!matchesFreq(v, currentFreq)) return false;

                // Search Filter
                if (query && !v['单词'].includes(query)) return false;

                return true;
            });

            // Update stats while we're at it (sync stats based on current view)
            updateCounts();
            
            if (masteredVerbs.length === 0) {
                grid.innerHTML = `
                    <div class="col-span-full py-20 text-center animate-fade-in">
                        <!-- Action Button: Analytics -->
                        <div onclick="window.globalResetPressedState(); showAnalytics()" class="action-card-btn neumorphic-btn-sm w-16 h-16 flex items-center justify-center text-blue-500 mx-auto mb-6 cursor-pointer transition-transform">
                            <i class="fas fa-seedling text-2xl"></i>
                        </div>
                        <h3 class="text-xl font-black text-gray-700 mb-2">Mastery</h3>
                        <p class="text-gray-400 font-bold text-xs mb-8">Your journey begins! Master words to see them here.</p>
                    </div>`;
                return;
            }
            
            grid.innerHTML = '';
            masteredVerbs.forEach(v => {
                // Ensure createVerbCard generates interactive blocks
                const card = createVerbCard(v);
                grid.appendChild(card);
            });
        }

        function updateCheckinCalendar() {
            const calendar = document.getElementById('checkin-calendar');
            const streakBadge = document.getElementById('checkin-streak');
            if (!calendar) return;

            // Uses global checkinHistory (array of dates)
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Calculate streak (consecutive days ending today or yesterday)
            let streak = 0;
            let tempDate = new Date(today);
            
            // If not checked in today, start checking from yesterday
            if (!checkinHistory.includes(tempDate.toISOString().split('T')[0])) {
                tempDate.setDate(tempDate.getDate() - 1);
            }
            
            while (checkinHistory.includes(tempDate.toISOString().split('T')[0])) {
                streak++;
                tempDate.setDate(tempDate.getDate() - 1);
            }
            if (streakBadge) {
                streakBadge.innerHTML = `
                    <i class="fas fa-fire-alt text-[10px]"></i>
                    <span>${streak} Day Streak</span>
                `;
            }

            // Generate 7 days view (Ending with today)
            let html = '';
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                const isChecked = checkinHistory.includes(dateStr);
                const isToday = i === 0;
                const dayName = days[date.getDay()];
                const dayNum = date.getDate();

                html += `
                    <div class="flex-1 flex flex-col items-center gap-1.5 group">
                        <span class="text-[10px] font-black ${isToday ? 'text-blue-500' : 'text-gray-400'} uppercase tracking-tighter">${dayName}</span>
                        <div class="w-8 h-8 rounded-xl flex items-center justify-center transition-all duration-300 relative
                                    ${isChecked 
                                      ? 'bg-gradient-to-br from-blue-400 to-blue-600 shadow-[0_4px_12px_rgba(59,130,246,0.3)]' 
                                      : 'neumorphic-inset bg-gray-50'}">
                            <span class="text-xs font-black ${isChecked ? 'text-white' : 'text-gray-400'}">${dayNum}</span>
                            ${isChecked ? '<i class="fas fa-check text-[6px] text-white/80 absolute -bottom-1 -right-1 bg-blue-500 rounded-full w-3 h-3 flex items-center justify-center border border-white shadow-sm"></i>' : ''}
                        </div>
                    </div>
                `;
            }
            calendar.innerHTML = html;
        }

        async function manualCheckin(dateStr) {
            const isChecked = checkinHistory.includes(dateStr);
            try {
                if (isChecked) {
                    await fetch(`/api/checkins/${dateStr}`, { method: 'DELETE' });
                    checkinHistory = checkinHistory.filter(d => d !== dateStr);
                } else {
                    await fetch('/api/checkins', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ date: dateStr })
                    });
                    if (!checkinHistory.includes(dateStr)) checkinHistory.push(dateStr);
                }
                updateCheckinCalendar();
                autoCheckin();
                
                // Visual feedback
                const notification = document.createElement('div');
                notification.className = 'fixed top-20 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-4 py-2 rounded-full text-xs font-black shadow-lg z-[2000] animate-bounce';
                notification.innerText = !isChecked ? 'Daily Check-in Successful! 🚀' : 'Check-in Cancelled! 🗑️';
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 2000);
            } catch (e) {
                console.error("Manual check-in failed:", e);
                showMessage('Error', 'Failed to sync check-in status', 'error');
            }
        }

        async function autoCheckin() {
            const today = new Date().toISOString().split('T')[0];
            const todayStart = new Date();
            todayStart.setHours(0, 0, 0, 0);
            
            // Calculate Today's Progress locally (Sync with Header Today)
            // User request: "New" count should match the "Today" header count
            let todayCount = 0;
            let dueCount = 0;
            const now = new Date();

            Object.values(learningStatus).forEach(status => {
                // Today Count (Any review today)
                if (status.last_review && new Date(status.last_review) >= todayStart) {
                    todayCount++;
                }
                // Due Count
                if (status.status === 'learning' && new Date(status.next_review) <= now) {
                    dueCount++;
                }
            });
            
            // If already checked in today, no need to re-check
            if (checkinHistory.includes(today)) {
                // Still update UI stats if present
                const progressEl = document.getElementById('daily-goal-progress');
                if (progressEl) {
                    progressEl.style.width = '100%';
                    const statsText = document.getElementById('daily-goal-text');
                    if (statsText) {
                        statsText.innerText = `Goal Achieved! 🚀`;
                        statsText.className = 'text-[10px] font-black uppercase tracking-tight text-green-500';
                    }
                }
                return;
            }

            const DAILY_NEW_GOAL = 40;

            try {
                // Use local calculation instead of backend API to ensure consistency with Header Today count
                const newWordsToday = todayCount;
                const dueWordsRemaining = dueCount;

                // Update UI Progress
                const progressEl = document.getElementById('daily-goal-progress');
                if (progressEl) {
                    const newPercent = Math.min(100, (newWordsToday / DAILY_NEW_GOAL) * 100);
                    progressEl.style.width = `${newPercent}%`;
                    
                    const statsText = document.getElementById('daily-goal-text');
                    if (statsText) {
                        statsText.innerText = `${newWordsToday}/${DAILY_NEW_GOAL} New | ${dueWordsRemaining} Due`;
                        statsText.className = `text-[10px] font-black uppercase tracking-tight ${dueWordsRemaining === 0 && newWordsToday >= DAILY_NEW_GOAL ? 'text-green-500' : 'text-gray-400'}`;
                    }
                }

                // Check if criteria met: 40+ new words AND 0 due reviews
                if (newWordsToday >= DAILY_NEW_GOAL && dueWordsRemaining === 0) {
                    await fetch('/api/checkins', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ date: today }),
                        signal: pageAbortController.signal
                    });
                    if (!checkinHistory.includes(today)) checkinHistory.push(today);
                    updateCheckinCalendar();
                    
                    // Show achievement notification
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-20 left-1/2 -translate-x-1/2 bg-green-600 text-white px-6 py-3 rounded-2xl text-xs font-black shadow-xl z-[2000] animate-bounce border-2 border-white/20 backdrop-blur-md';
                    notification.innerHTML = '<div class="flex items-center gap-2"><i class="fas fa-trophy text-yellow-300"></i> Daily Goal Achieved! Check-in Recorded! 🚀</div>';
                    document.body.appendChild(notification);
                    setTimeout(() => notification.remove(), 4000);
                }
            } catch (e) {
                if (e.name === 'AbortError') return;
                console.error("Error in autoCheckin:", e);
            }
        }

        function updateProfileStats() {
            updateCheckinCalendar();
            autoCheckin();
            // Global statistics: independent of current POS/Freq study filters
            // but respects the current search query and exclusion status
            const query = document.getElementById('searchInput')?.value || '';
            
            const targetVerbs = allVerbs.filter(v => {
                // Search filter
                if (query && !v['单词'].includes(query)) return false;
                // Exclude excluded verbs from progress stats
                if (excludedVerbs.has(v['单词'])) return false;
                return true;
            });

            // 1. Calculate Status Stats
            const stats = {
                new: 0,
                learning: 0,
                reviewing: 0,
                mastered: 0,
                total: targetVerbs.length
            };

            const now = new Date();
            targetVerbs.forEach(v => {
                const status = learningStatus[v['单词'].toLowerCase()];
                if (!status) {
                    stats.new++;
                } else if (status.status === 'mastered') {
                    stats.mastered++;
                } else if (new Date(status.next_review) <= now) {
                    stats.reviewing++;
                } else {
                    stats.learning++;
                }
            });

            // 2. Update Status Count UI
            const statusContainer = document.getElementById('me-tab-status');
            if (statusContainer) {
                const createStatItem = (label, count, colorClass, icon, bgClass) => `
                    <div class="learning-insight-card flex flex-col p-4 neumorphic-inset rounded-2xl bg-gradient-to-br ${bgClass}/10 to-transparent border border-white/60 relative overflow-hidden transition-all duration-300">
                        <!-- Subtle Background Icon -->
                        <i class="fas ${icon} absolute -right-2 -bottom-2 text-4xl opacity-[0.03] transition-opacity"></i>
                        
                        <div class="flex items-center justify-between mb-2.5 relative z-10">
                            <div class="w-8 h-8 rounded-xl bg-white/80 backdrop-blur-sm neumorphic flex items-center justify-center shadow-sm">
                                <i class="fas ${icon} ${colorClass} text-xs"></i>
                            </div>
                            <span class="text-[11px] font-black ${colorClass} bg-white/70 backdrop-blur-sm px-2 py-0.5 rounded-lg shadow-[0_1px_3px_rgba(0,0,0,0.05)] border border-white/50">${Math.round(count/stats.total*100)||0}%</span>
                        </div>
                        <div class="relative z-10">
                            <p class="font-black text-gray-400 text-[10px] uppercase tracking-[0.15em] mb-1.5 opacity-80">${label}</p>
                            <span class="text-xl font-black text-gray-700 leading-none tracking-tight">${count.toLocaleString()}</span>
                        </div>
                    </div>
                `;

                statusContainer.innerHTML = `
                    ${createStatItem('New Words', stats.new, 'text-gray-400', 'fa-plus', 'from-gray-400')}
                    ${createStatItem('Learning', stats.learning, 'text-blue-500', 'fa-book-reader', 'from-blue-500')}
                    ${createStatItem('Due Review', stats.reviewing, 'text-orange-500', 'fa-clock', 'from-orange-500')}
                    ${createStatItem('Mastered', stats.mastered, 'text-green-500', 'fa-trophy', 'from-green-500')}
                `;
            }

            // 3. Update Overall Progress Bar (Global: all 5530 words)
            const globalTotal = allVerbs.length || 5530;
            const startedCount = Object.keys(learningStatus).length;
            const excludedCount = excludedVerbs.size;
            const globalPercent = globalTotal > 0 ? Math.round(((startedCount + excludedCount) / globalTotal) * 100) : 0;
            
            safeUpdate('profile-progress-percent', globalPercent + '%');
            
            setTimeout(() => {
                const bar = document.getElementById('profile-progress-bar');
                if (bar) bar.style.width = globalPercent + '%';
            }, 100);

            // 4. Update POS Breakdown
            const breakdownContainer = document.getElementById('me-tab-breakdown');
            if (breakdownContainer) {
                const posStats = {};
                targetVerbs.forEach(v => {
                    const pos = v.pos || 'other';
                    if (!posStats[pos]) posStats[pos] = { total: 0, mastered: 0 };
                    posStats[pos].total++;
                    if (learningStatus[v['单词'].toLowerCase()]?.status === 'mastered') {
                        posStats[pos].mastered++;
                    }
                });

                const sortedPos = Object.entries(posStats).sort((a, b) => b[1].total - a[1].total).slice(0, 6);
                
                breakdownContainer.innerHTML = '';
                sortedPos.forEach(([pos, s]) => {
                    const p = s.total > 0 ? Math.round((s.mastered / s.total) * 100) : 0;
                    const posLabel = pos.charAt(0).toUpperCase() + pos.slice(1).replace('_', ' ');
                    
                    const item = document.createElement('div');
                    item.className = 'space-y-2';
                    item.innerHTML = `
                        <div class="flex justify-between items-end">
                            <div class="flex items-center gap-2">
                                <div class="w-1.5 h-1.5 rounded-full bg-blue-400 shadow-[0_0_8px_rgba(96,165,250,0.5)]"></div>
                                <span class="text-xs font-black text-gray-600 uppercase tracking-wider">${posLabel}</span>
                            </div>
                            <div class="flex items-baseline gap-1">
                                <span class="text-xs font-black text-gray-700">${s.mastered}</span>
                                <span class="text-[10px] font-bold text-gray-400">/ ${s.total}</span>
                            </div>
                        </div>
                        <div class="w-full bg-gray-200 h-2.5 rounded-full overflow-hidden neumorphic-inset p-0.5">
                            <div class="bg-gradient-to-r from-blue-300 to-blue-500 h-full rounded-full transition-all duration-1000 shadow-sm" style="width: ${p}%"></div>
                        </div>
                    `;
                    breakdownContainer.appendChild(item);
                });

                if (sortedPos.length === 0) {
                    breakdownContainer.innerHTML = '<div class="text-center py-4 text-[10px] font-bold text-gray-400 uppercase tracking-widest">No data available</div>';
                }
            }
        }

        function showAnalytics() {
            const modal = document.getElementById('analyticsModal');
            if (!modal) return;
            
            pushModalState(closeAnalytics);
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('div').classList.remove('scale-95');
                modal.querySelector('div').classList.add('scale-100');
                // Render chart after modal is visible to get correct width
                renderEbbinghausChart('ebbinghausChart');
            }, 10);
        }

        function closeAnalytics(fromPopState = false) {
            const modal = document.getElementById('analyticsModal');
            if (!modal) return;
            
            if (fromPopState !== true) {
                // const idx = modalStack.indexOf(closeAnalytics);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        // --- Search Modal Logic ---
        function openSearchModal() {
            const modal = document.getElementById('searchModal');
            const modalInput = document.getElementById('modalSearchInput');
            const mainInput = document.getElementById('searchInput');
            
            if (!modal || !modalInput) return;
            
            // Sync initial value
            modalInput.value = mainInput ? mainInput.value : '';
            
            pushModalState(closeSearchModal);
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('div').classList.remove('-translate-y-4');
                modal.querySelector('div').classList.add('translate-y-0');
                modalInput.focus();
            }, 10);
        }

        function closeSearchModal(fromPopState = false) {
            const modal = document.getElementById('searchModal');
            if (!modal) return;
            
            if (fromPopState !== true) {
                // const idx = modalStack.indexOf(closeSearchModal);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('translate-y-0');
            modal.querySelector('div').classList.add('-translate-y-4');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        function syncSearch(value) {
            const mainInput = document.getElementById('searchInput');
            if (mainInput) {
                mainInput.value = value;
                // Trigger filter
                filterVerbs();
            }
        }

        function checkSearchWidth() {
            const container = document.getElementById('search-container');
            const mainInput = document.getElementById('searchInput');
            if (!container || !mainInput) return;
            
            // If container width is less than 160px, it's considered too narrow for comfortable typing
            if (container.offsetWidth < 160) {
                if (!mainInput.readOnly) {
                    mainInput.readOnly = true;
                    mainInput.placeholder = "Tap to search...";
                    mainInput.onclick = openSearchModal;
                    // Also make the container parent clickable for better UX
                    mainInput.parentElement.onclick = openSearchModal;
                    mainInput.parentElement.style.cursor = 'pointer';
                }
            } else {
                if (mainInput.readOnly) {
                    mainInput.readOnly = false;
                    mainInput.placeholder = "Search words...";
                    mainInput.onclick = null;
                    mainInput.parentElement.onclick = null;
                    mainInput.parentElement.style.cursor = 'default';
                }
            }
        }

        // Add resize listener for search width check
        window.addEventListener('resize', checkSearchWidth);
        // Also check on load after a short delay to ensure layout is ready
        setTimeout(checkSearchWidth, 500);

        function switchMeTab(tab) {
            const tabs = ['status', 'breakdown'];
            tabs.forEach(t => {
                const content = document.getElementById(`me-tab-${t}`);
                const btn = document.getElementById(`btn-me-${t}`);
                if (content && btn) {
                    if (t === tab) {
                        content.classList.remove('hidden');
                        btn.classList.add('bg-white', 'shadow-sm', 'text-blue-600');
                        btn.classList.remove('text-gray-500');
                    } else {
                        content.classList.add('hidden');
                        btn.classList.remove('bg-white', 'shadow-sm', 'text-blue-600');
                        btn.classList.add('text-gray-500');
                    }
                }
            });
        }

        // Global AbortController for cleaning up pending requests
        let pageAbortController = new AbortController();
        let statusSyncTimer = null;

        function startStatusSync() {
            if (statusSyncTimer) clearInterval(statusSyncTimer);
            // Every 10 seconds, check if any displayed verbs have new cache
            statusSyncTimer = setInterval(async () => {
                if (currentPage !== 'learn' && currentPage !== 'review' && currentPage !== 'mastery') return;
                
                const visibleWords = displayedVerbs
                    .filter(v => !v.has_cache)
                    .map(v => v['单词'].trim().toLowerCase());
                
                if (visibleWords.length === 0) return;

                try {
                    // We can reuse the /api/verbs endpoint but just for the words we care about
                    // Or more efficiently, just check a subset. 
                    // For now, let's just refresh the learning status and check if any of these words 
                    // now have an explanation in the DB.
                    const res = await fetch('/api/check_cache', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ verbs: visibleWords })
                    });
                    
                    if (res.ok) {
                        const cachedList = await res.json(); // Array of words that now have cache
                        if (cachedList && cachedList.length > 0) {
                            cachedList.forEach(word => {
                                const vIndex = displayedVerbs.findIndex(v => v['单词'].trim().toLowerCase() === word);
                                if (vIndex !== -1) {
                                    displayedVerbs[vIndex].has_cache = true;
                                    // Update the DOM for this specific card
                                    const card = document.getElementById('verb-card-' + word);
                                    /* Refresh button removed per user request
                                    if (card && !card.querySelector('button[onclick*="refreshFromCard"]')) {
                                        const refreshBtnHtml = `
                                            <button 
                                                onclick="refreshFromCard(event, '${word}')"
                                                class="absolute bottom-2 right-2 w-8 h-8 rounded-full bg-white/90 hover:bg-white text-blue-500 hover:text-blue-600 flex items-center justify-center opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all shadow-sm z-10 border border-blue-100"
                                                title="Refresh explanation"
                                            >
                                                <i class="fas fa-sync-alt text-xs"></i>
                                            </button>
                                        `;
                                        card.insertAdjacentHTML('beforeend', refreshBtnHtml);
                                    }
                                    */
                                }
                            });
                        }
                    }
                } catch (e) {
                    console.warn("Status sync failed:", e);
                }
            }, 10000); // 10 seconds interval
        }

        window.addEventListener('beforeunload', () => {
            pageAbortController.abort();
            if (statusSyncTimer) clearInterval(statusSyncTimer);
        });

        // Global handler to suppress AbortError in the console
        window.addEventListener('unhandledrejection', (event) => {
            if (event.reason && event.reason.name === 'AbortError') {
                event.preventDefault();
            }
        });

        async function loadLearningStatus(retries = 3) {
            try {
                const res = await fetch('/api/ebbinghaus/status', {
                    signal: pageAbortController.signal
                });
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                learningStatus = await res.json();
            } catch (e) {
                // Ignore abort errors which are normal during reloads
                if (e.name === 'AbortError') return;

                // Silently retry without console.error for initial failed fetches during reloads
                if (retries > 0) {
                    setTimeout(() => loadLearningStatus(retries - 1), 1000);
                } else {
                    console.error("Error loading learning status:", e);
                }
            }
        }

        // --- Synced Data Logic (Backend Persisted) ---
        let checkinHistory = []; 
        let savedBatch = [];

        async function loadSyncedData() {
            try {
                const [checkinsRes, batchRes] = await Promise.all([
                    fetch('/api/checkins', { signal: pageAbortController.signal }),
                    fetch('/api/learn_batch', { signal: pageAbortController.signal })
                ]);
                if (checkinsRes.ok) {
                    const data = await checkinsRes.json();
                    checkinHistory = Array.isArray(data) ? data : [];
                }
                if (batchRes.ok) savedBatch = await batchRes.json();
            } catch (e) {
                if (e.name === 'AbortError') return;
                console.error("Error loading synced data:", e);
                // Ensure array even on error
                if (!Array.isArray(checkinHistory)) checkinHistory = [];
            }
        }

        async function migrateDataToBackend() {
            // 1. Migrate Check-ins
            const localCheckinsRaw = localStorage.getItem('checkin_history');
            if (localCheckinsRaw) {
                try {
                    const localCheckins = JSON.parse(localCheckinsRaw);
                    // Handle both array (new) and object (old) formats
                    let localCheckinDates = [];
                    if (Array.isArray(localCheckins)) {
                        localCheckinDates = localCheckins;
                    } else if (typeof localCheckins === 'object' && localCheckins !== null) {
                        localCheckinDates = Object.keys(localCheckins);
                    }

                    if (localCheckinDates.length > 0) {
                        console.log("Migrating check-ins to backend...");
                        for (const date of localCheckinDates) {
                            await fetch('/api/checkins', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ date }),
                                signal: pageAbortController.signal
                            });
                        }
                    }
                } catch (e) { 
                    if (e.name !== 'AbortError') console.error("Migration error (checkins):", e); 
                }
                localStorage.removeItem('checkin_history');
            }

            // 2. Migrate Learn Batch
            const localBatchRaw = localStorage.getItem('netem_learn_batch');
            if (localBatchRaw) {
                try {
                    const localBatch = JSON.parse(localBatchRaw);
                    if (Array.isArray(localBatch) && localBatch.length > 0) {
                        console.log("Migrating learn batch to backend...");
                        await fetch('/api/learn_batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(localBatch),
                            signal: pageAbortController.signal
                        });
                    }
                } catch (e) { 
                    if (e.name !== 'AbortError') console.error("Migration error (batch):", e); 
                }
                localStorage.removeItem('netem_learn_batch');
            }

            // 3. Clear new words history (redundant now)
            localStorage.removeItem('netem_new_words_history');
        }

        // --- Clear All Progress Logic ---
        let clearCountdownTimer = null;
        function clearLearningData() {
            const modal = document.getElementById('clearAllModal');
            if (!modal) return;
            
            pushModalState(closeClearAllModal);
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('div').classList.remove('scale-95');
                modal.querySelector('div').classList.add('scale-100');
            }, 10);

            // Handle Countdown
            const btnProgress = document.getElementById('btn-clear-progress');
            const btnInit = document.getElementById('btn-full-init');
            const countdownTexts = modal.querySelectorAll('.countdown-text');
            let seconds = 5;

            // Reset buttons to disabled state
            [btnProgress, btnInit].forEach(btn => {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed');
            });
            countdownTexts.forEach(el => el.innerText = `(${seconds}s)`);

            if (clearCountdownTimer) clearInterval(clearCountdownTimer);
            clearCountdownTimer = setInterval(() => {
                seconds--;
                if (seconds <= 0) {
                    clearInterval(clearCountdownTimer);
                    clearCountdownTimer = null;
                    [btnProgress, btnInit].forEach(btn => {
                        btn.disabled = false;
                        btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    });
                    countdownTexts.forEach(el => el.innerText = '');
                } else {
                    countdownTexts.forEach(el => el.innerText = `(${seconds}s)`);
                }
            }, 1000);

            // Option 1: Clear Progress Only
            btnProgress.onclick = async () => {
                try {
                    const res = await fetch('/api/ebbinghaus/clear_all', { method: 'POST' });
                    if (res.ok) {
                        learningStatus = {};
                        checkinHistory = [];
                        savedBatch = [];
                        // Clear any legacy storage
                        localStorage.removeItem('netem_new_words_history');
                        localStorage.removeItem('checkin_history');
                        localStorage.removeItem('netem_learn_batch');
                        
                        finishClearance('Learning progress cleared successfully');
                    }
                } catch (e) { handleClearError(e); }
            };

            // Option 2: Full Initialize
            btnInit.onclick = async () => {
                try {
                    // 1. Clear backend data (including settings)
                    const res = await fetch('/api/ebbinghaus/clear_all?reset_settings=true', { method: 'POST' });
                    const result = await res.json();
                    
                    if (res.ok) {
                        // 2. Clear ALL local storage
                        localStorage.clear();
                        // 3. Reset local variables
                        learningStatus = {};
                        excludedVerbs = new Set();
                        
                        finishClearance('Application reset successfully');
                        // Optional: reload to ensure clean state
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        throw new Error(result.detail || 'Server error');
                    }
                } catch (e) { 
                    console.error("Full init error:", e);
                    handleClearError(e); 
                }
            };
        }

        function finishClearance(msg) {
            updateCounts();
            updateProfileStats();
            
            // Refresh current page UI
            if (currentPage === 'learn') applyFilters();
            else if (currentPage === 'review') renderReviewPage();
            else if (currentPage === 'mastery') renderMasteryPage();
            else if (currentPage === 'me') {
                const container = document.getElementById('ebbinghausChart');
                if (container) renderEbbinghausChart('ebbinghausChart');
            }
            
            closeClearAllModal();
            showMessage('Success', msg, 'success');
        }

        function handleClearError(e) {
            console.error("Error clearing data:", e);
            closeClearAllModal();
            const errorMsg = e.message || 'Operation failed, please try again';
            showMessage('Error', errorMsg, 'error');
        }

        function closeClearAllModal(fromPopState = false) {
            const modal = document.getElementById('clearAllModal');
            if (!modal) return;
            
            if (fromPopState !== true) {
                // const idx = modalStack.indexOf(closeClearAllModal);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            
            // Clear timer if modal is closed
            if (clearCountdownTimer) {
                clearInterval(clearCountdownTimer);
                clearCountdownTimer = null;
            }
            
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        function showMessage(title, text, type = 'info') {
            const modal = document.getElementById('messageModal');
            const titleEl = document.getElementById('messageTitle');
            const textEl = document.getElementById('messageText');
            const iconEl = document.getElementById('messageIcon');
            
            if (!modal || !titleEl || !textEl || !iconEl) return;

            pushModalState(closeMessageModal);
            titleEl.innerText = title;
            textEl.innerText = text;
            
            // Set icon and color based on type
            const icon = iconEl.querySelector('i');
            icon.className = 'fas';
            if (type === 'success') {
                icon.classList.add('fa-check-circle', 'text-green-500');
            } else if (type === 'error') {
                icon.classList.add('fa-exclamation-circle', 'text-red-500');
            } else {
                icon.classList.add('fa-info-circle', 'text-blue-500');
            }

            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('div').classList.remove('scale-95');
                modal.querySelector('div').classList.add('scale-100');
            }, 10);
        }

        function showConfirm(title, text, onOk) {
            const modal = document.getElementById('confirmModal');
            const titleEl = document.getElementById('confirmTitle');
            const textEl = document.getElementById('confirmText');
            const okBtn = document.getElementById('confirmOkBtn');
            const cancelBtn = document.getElementById('confirmCancelBtn');

            if (!modal || !titleEl || !textEl || !okBtn || !cancelBtn) return;

            titleEl.innerText = title;
            textEl.innerText = text;

            const close = (fromPopState = false) => {
                if (fromPopState !== true) {
                    // const idx = modalStack.indexOf(close);
                    // if (idx > -1) modalStack.splice(idx, 1);
                    history.back();
                }
                modal.classList.add('opacity-0');
                modal.querySelector('div').classList.remove('scale-100');
                modal.querySelector('div').classList.add('scale-95');
                setTimeout(() => modal.classList.add('hidden'), 300);
            };

            pushModalState(close);
            okBtn.onclick = () => {
                close();
                if (onOk) onOk();
            };

            cancelBtn.onclick = close;

            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('div').classList.remove('scale-95');
                modal.querySelector('div').classList.add('scale-100');
            }, 10);
        }

        function closeMessageModal(fromPopState = false) {
            const modal = document.getElementById('messageModal');
            if (!modal) return;
            
            if (fromPopState !== true) {
                // const idx = modalStack.indexOf(closeMessageModal);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }
        
        // Excluded Verbs (LocalStorage)
        let excludedVerbs = new Set();
        let pendingUnexclude = new Set(); // Track words to be unexcluded on save
        try {
            const saved = localStorage.getItem('excludedVerbs');
            if (saved) {
                excludedVerbs = new Set(JSON.parse(saved));
            }
        } catch (e) {
            console.error("Error loading excluded verbs:", e);
        }

        // Cloud Sync & Export/Import Logic
        async function cloudSync() {
            showConfirm('Export Data', 'This will prepare a backup of your progress and configuration. Continue?', async () => {
                const syncBtn = document.querySelector('[onclick="cloudSync()"]');
                const syncIcon = syncBtn.querySelector('i');
                const syncText = document.getElementById('sync-status-text');
                
                try {
                    // Visual feedback: Start rotating
                    syncIcon.classList.add('fa-spin');
                    syncBtn.disabled = true;
                    
                    // Show info message
                    showMessage('Exporting', 'Preparing your data backup, please wait...', 'info');
                    
                    // Get excluded verbs as JSON string
                    const excludedData = localStorage.getItem('excludedVerbs') || '[]';
                    
                    // Trigger Export with excluded verbs
                    const response = await fetch(`/api/export?excluded_verbs=${encodeURIComponent(excludedData)}`);
                    if (!response.ok) throw new Error('Export failed');
                    
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `netem_backup_${new Date().toISOString().split('T')[0]}.zip`;
                    document.body.appendChild(a);
                    
                    // Detect if the user actually triggered the download
                    let downloadTriggered = false;
                    const onFocus = () => {
                        window.removeEventListener('focus', onFocus);
                        // Small delay to allow browser to handle the click
                        setTimeout(() => {
                            if (downloadTriggered) {
                                if (syncText) syncText.innerText = `Last export: Just now (Success)`;
                                showMessage('Export Success', 'Your progress and configuration have been backed up successfully.', 'success');
                            }
                        }, 500);
                    };

                    a.onclick = () => {
                        downloadTriggered = true;
                        window.addEventListener('focus', onFocus);
                    };

                    a.click();
                    window.URL.revokeObjectURL(url);
                    a.remove();
                    
                } catch (e) {
                    console.error("Sync error:", e);
                    showMessage('Export Failed', 'Unable to connect to the server for backup.', 'error');
                } finally {
                    syncIcon.classList.remove('fa-spin');
                    syncBtn.disabled = false;
                }
            });
        }

        async function triggerImport() {
            showConfirm('Restore Data', 'Importing a backup will overwrite all your current progress. Continue?', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.zip';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    try {
                        showMessage('Importing', 'Restoring your data, please wait...', 'info');
                        const res = await fetch('/api/import', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (res.ok) {
                            const data = await res.json();
                            
                            // Handle excluded verbs if returned from backend
                            if (data.excluded_verbs) {
                                localStorage.setItem('excludedVerbs', data.excluded_verbs);
                                try {
                                    excludedVerbs = new Set(JSON.parse(data.excluded_verbs));
                                } catch (e) {
                                    console.error("Error parsing imported excluded verbs:", e);
                                }
                            }
                            
                            const syncText = document.getElementById('sync-status-text');
                              if (syncText) syncText.innerText = `Last import: Just now (Success)`;
                              showMessage('Import Success', 'Data restored successfully. The page will now reload.', 'success');
                            setTimeout(() => location.reload(), 2000);
                        } else {
                            const error = await res.json();
                            showMessage('Import Failed', error.detail || 'Please check if the backup file is valid.', 'error');
                        }
                    } catch (err) {
                        console.error("Import error:", err);
                        showMessage('Import Failed', 'A network or server error occurred.', 'error');
                    }
                };
                input.click();
            });
        }

        // State Persistence
        const STATE_KEY = 'netem_vocab_state';
        const LEARN_BATCH_KEY = 'netem_learn_batch';
        
        async function updateSavedBatch(newBatchOrWordToRemove) {
            try {
                if (Array.isArray(newBatchOrWordToRemove)) {
                    savedBatch = newBatchOrWordToRemove;
                } else if (typeof newBatchOrWordToRemove === 'string') {
                    savedBatch = savedBatch.filter(w => w.toLowerCase() !== newBatchOrWordToRemove.toLowerCase());
                }
                
                // Ensure we are sending an array
                if (!Array.isArray(savedBatch)) {
                    savedBatch = [];
                }
                
                await fetch('/api/learn_batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(savedBatch)
                });
            } catch (e) {
                console.error("Error updating saved batch:", e);
            }
        }
        
        function saveState() {
            const state = {
                currentPos,
                currentFreq,
                currentPage, // Add currentPage to state
                scrollY: window.scrollY,
                displayedCount: offset, 
                searchInput: document.getElementById('searchInput')?.value || ''
            };
            localStorage.setItem(STATE_KEY, JSON.stringify(state));
        }

        // Save state on scroll (throttled) and page hide
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            if (scrollTimeout) return;
            scrollTimeout = setTimeout(() => {
                saveState();
                scrollTimeout = null;
            }, 500);
        });
        
        window.addEventListener('visibilitychange', () => {
            if (document.hidden) saveState();
        });

        // Init
        document.addEventListener('DOMContentLoaded', async () => {
            // Restore Page First to prevent flash
            let targetPage = 'learn';
            try {
                const savedState = localStorage.getItem(STATE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (state.currentPage) {
                        targetPage = state.currentPage;
                    }
                    
                    // Clear any lingering modal states on fresh load
                    if (state.activeVerb) {
                        delete state.activeVerb;
                        delete state.isReviewMode;
                        localStorage.setItem(STATE_KEY, JSON.stringify(state));
                    }
                }
            } catch (e) {}
            
            // Always call switchPage to ensure correct initial UI state
            switchPage(targetPage);
            
            // Add click listener to modal overlay for closing
            const modalOverlay = document.getElementById('learningModal');
            if (modalOverlay) {
                modalOverlay.addEventListener('mousedown', (e) => {
                    if (e.target === modalOverlay) {
                        closeModal();
                    }
                });
            }
            
            // Mark body as ready to show the restored page
            document.body.classList.add('ready');

            // --- Synced Data Migration & Loading ---
            await migrateDataToBackend();
            await loadSyncedData();

            await loadLearningStatus();
            loadVerbs();
            renderExcludedVerbs(); // Update badge on load
            
            // Initialize filter scroll indicators
            setTimeout(() => {
                document.querySelectorAll('.filter-scroll-container > div').forEach(el => handleFilterScroll(el));
            }, 500);
        });

        function handleFilterScroll(el) {
            if (!el) return;
            const container = el.parentElement;
            if (!container) return;

            // Left side shadow
            if (el.scrollLeft > 5) {
                container.classList.add('is-scrolled');
            } else {
                container.classList.remove('is-scrolled');
            }

            // Right side shadow
            const canScrollRight = el.scrollWidth > (el.clientWidth + el.scrollLeft + 5);
            if (canScrollRight) {
                container.classList.add('can-scroll-right');
            } else {
                container.classList.remove('can-scroll-right');
            }
        }

        // Initialize scroll indicators on resize and load
        window.addEventListener('resize', () => {
            document.querySelectorAll('.filter-scroll-container > div').forEach(el => handleFilterScroll(el));
        });

        async function loadVerbs(retries = 5) {
            isLoading = true;
            // Show loading skeleton if grid is empty
            const grid = document.getElementById('verbsGrid');
            if (grid && grid.children.length === 0) {
                grid.innerHTML = `
                    <div class="col-span-full py-20 flex flex-col items-center justify-center space-y-4 animate-fade-in">
                        <div class="w-12 h-12 border-4 border-blue-200 border-t-blue-500 rounded-full animate-spin"></div>
                        <p class="text-gray-400 text-xs font-bold uppercase tracking-widest animate-pulse">Loading Vocabulary...</p>
                    </div>
                `;
            }

            try {
                // Load more verbs to ensure we have enough for groups
                const res = await fetch(`/api/verbs?limit=6000&offset=0&_t=${Date.now()}`);  
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                const data = await res.json();
                
                if (data.items) {
                    allVerbs = data.items.map(item => {
                        // Pre-calculate group
                        item.group = getGroup(item['词频']);
                        return item;
                    });
                    
                    // Restore State
                    try {
                        const savedState = localStorage.getItem(STATE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    if (state.searchInput) {
                        const searchInput = document.getElementById('searchInput');
                        if (searchInput) searchInput.value = state.searchInput;
                    }

                    if (state.currentPos) {
                        currentPos = Array.isArray(state.currentPos) ? state.currentPos : [state.currentPos];
                        // Update UI buttons
                        document.querySelectorAll('[data-pos]').forEach(btn => {
                            btn.classList.toggle('active', currentPos.includes(btn.dataset.pos));
                        });
                    }
                    
                    if (state.currentFreq) {
                        currentFreq = Array.isArray(state.currentFreq) ? state.currentFreq : [state.currentFreq];
                        // Update UI buttons
                        document.querySelectorAll('[data-freq]').forEach(btn => {
                            btn.classList.toggle('active', currentFreq.includes(btn.dataset.freq));
                        });
                    }
                    
                    // Adjust initial limit to cover what was seen
                    if (state.displayedCount && state.displayedCount > 4) {
                        limit = state.displayedCount;
                    }
                }
                    } catch (e) {
                        console.error("Error restoring state:", e);
                    }
                    
                    updateCounts();
                    applyFilters();
                    updateProfileStats(); // Restore profile stats on load
                    
                    // Re-trigger current page logic now that data is loaded
                    if (currentPage === 'review') {
                        renderReviewPage();
                    } else if (currentPage === 'mastery') {
                        renderMasteryPage();
                    }
                    
                    startStatusSync(); // Start periodic status synchronization
                    
                    // Restore Scroll Position
                    try {
                        const savedState = localStorage.getItem(STATE_KEY);
                        if (savedState) {
                            const state = JSON.parse(savedState);
                            
                            // 1. Restore Active Modal Card
                            if (state.activeVerb) {
                                openVerb(state.activeVerb);
                            }
                            
                            // 2. Restore Scroll Position
                            if (state.scrollY) {
                                setTimeout(() => {
                                    window.scrollTo(0, state.scrollY);
                                    // Reset limit back to default (4) for subsequent manual loads
                                    limit = 4; 
                                }, 100);
                            }
                        }
                    } catch (e) {}
                    
                }
            } catch (e) {
                console.error("Error loading verbs:", e);
                if (retries > 0) {
                    console.log(`Retrying to load verbs (${retries} attempts left)...`);
                    // Exponential backoff for retry: 1s, 2s, 4s, 8s, 16s
                    const delay = Math.pow(2, 5 - retries) * 1000;
                    setTimeout(() => loadVerbs(retries - 1), delay);
                } else {
                    document.getElementById('verbsGrid').innerHTML = `<div class="col-span-full text-center text-red-500">Failed to load verbs after multiple attempts. Error: ${e.message} <br> Please refresh the page.</div>`;
                }
            } finally {
                isLoading = false;
            }
        }

        function getGroup(freq) {
            const f = parseInt(freq) || 0;
            const prob = parseFloat(calculateExamProbability(f));
            if (prob >= 80) return 'must';
            if (prob >= 44) return 'core';
            if (prob >= 25) return 'advanced';
            if (prob >= 10) return 'basic';
            return 'rare';
        }

        function updateCounts(filteredSubset = null) {
            updateKaoyanCountdown();
            // User request: "所有标签的数量显示以当时搜索的所有结果的分布为准"
            // Reverting logic to respect cross-filtering (linkage) between POS and Frequency
            
            const query = document.getElementById('searchInput').value;
            const searchMatches = allVerbs.filter(v => v['单词'].includes(query));

            // Reset counts
            const posCounts = { noun: 0, verb: 0, noun_verb: 0, other: 0, adj_adv: 0, prep_conj: 0, excluded: 0 };
            const freqCounts = { must: 0, core: 0, advanced: 0, basic: 0, rare: 0, other: 0, review: 0, mastered: 0 };
            const now = new Date();

            // 1. Calculate POS counts (Filter by Search AND Current Frequency)
            // We want to see available POS options within the current Frequency scope
            const matchesForPos = searchMatches.filter(v => {
                const verbKey = v['单词'].toLowerCase();
                const status = learningStatus[verbKey];
                const isExcluded = excludedVerbs.has(v['单词']);
                
                // Count excluded regardless of frequency filter
                if (isExcluded) return true;
                
                // User request: Stats should be "Full" (include Review/Mastered words)
                // We no longer filter out isLearned here for the COUNTS
                
                return matchesFreq(v, currentFreq);
            });

            matchesForPos.forEach(v => {
                const isExcluded = excludedVerbs.has(v['单词']);
                
                if (isExcluded) {
                    posCounts.excluded++;
                } else {
                    // Only count regular POS if NOT excluded
                    if (v.pos === 'prep' || v.pos === 'prep_conj') {
                        posCounts.prep_conj++;
                    } else if (v.pos === 'adj' || v.pos === 'adv' || v.pos === 'adj_adv') {
                        posCounts.adj_adv++;
                    } else if (v.pos && posCounts[v.pos] !== undefined) {
                        posCounts[v.pos]++;
                    } else {
                        // Fallback to other
                        posCounts.other++;
                    }
                }
            });
            
            // 2. Calculate Frequency counts (Filter by Search AND Current POS)
            // We want to see available Frequency options within the current POS scope
            let matchesForFreq = [];
            
            if (currentPos.includes('excluded')) {
                matchesForFreq = searchMatches.filter(v => excludedVerbs.has(v['单词']));
            } else {
                matchesForFreq = searchMatches.filter(v => {
                    if (excludedVerbs.has(v['单词'])) return false;
                    
                    // If we are looking for Review or Mastered words, don't filter them out!
                    // We only filter them out when counting the "Learnable" frequency groups
                    return matchesPos(v, currentPos);
                });
            }

            matchesForFreq.forEach(v => {
                const verbKey = v['单词'].toLowerCase();
                const status = learningStatus[verbKey];

                // Count towards frequency groups (Must, Core, etc.) - include all words
                if (v.group && freqCounts[v.group] !== undefined) {
                    freqCounts[v.group]++;
                }
                
                // Check review status for each visible item
                if (status) {
                    if (status.status === 'learning') {
                        freqCounts.review++;
                    }
                    if (status.status === 'mastered') {
                        freqCounts.mastered++;
                    }
                }
            });

            // Update DOM - POS Row
            // "All" count should include ALL items (including learned/mastered) but exclude excluded items
            const activeItemsCount = searchMatches.filter(v => !excludedVerbs.has(v['单词'])).length;
            
            safeUpdate('count-pos-all', activeItemsCount);
            safeUpdate('count-noun', posCounts.noun);
            safeUpdate('count-verb', posCounts.verb);
            safeUpdate('count-noun_verb', posCounts.noun_verb);
            safeUpdate('count-other', posCounts.other);
            safeUpdate('count-adj_adv', posCounts.adj_adv);
            safeUpdate('count-prep_conj', posCounts.prep_conj);
            // safeUpdate('count-excluded', posCounts.excluded); // Moved to settings

            // Update DOM - Freq Row
            // User request: "Learn/Review/Mastery 应该和当前选择的单词库范围相吻合"
            // We calculate stats based on the CURRENT POS and Frequency filter (the "Word Library" scope)
            // Header stats (Total/Review/Mastered) should reflect the progress within this combined scope
            const scopeStats = { total: 0, reviewing: 0, mastered: 0, due: 0, today: 0 };
            const todayStart = new Date();
            todayStart.setHours(0, 0, 0, 0);
            
            // Calculate stats based on current POS AND Frequency filter
            // We use allVerbs (not searchMatches) because the header/badge should reflect the overall progress in this library range
            const matchesCurrentSelection = allVerbs.filter(v => {
                if (excludedVerbs.has(v['单词'])) return false;
                return matchesPos(v, currentPos) && matchesFreq(v, currentFreq);
            });

            // The header stats (Total/Review/Mastered) reflect the current selection scope
            matchesCurrentSelection.forEach(v => {
                scopeStats.total++;
                const status = learningStatus[v['单词'].toLowerCase()];
                if (status) {
                    // Today's progress: Any word reviewed today
                    if (status.last_review && new Date(status.last_review) >= todayStart) {
                        scopeStats.today++;
                    }

                    // Reviewing: Any word in the Ebbinghaus cycle that is NOT mastered
                    if (status.status === 'learning') {
                        scopeStats.reviewing++;
                        
                        // Also track which ones are actually DUE for the bottom nav badge
                        if (new Date(status.next_review) <= now) {
                            scopeStats.due++;
                        }
                    }
                    if (status.status === 'mastered') scopeStats.mastered++;
                }
            });

            // Update Header Stats
            safeUpdate('header-count-total', scopeStats.total);
            safeUpdate('header-count-review', scopeStats.reviewing);
            safeUpdate('header-count-mastered', scopeStats.mastered);
            safeUpdate('header-count-today', scopeStats.today);

            // Update Header Progress Bar
            // User request: Progress should be (any stage words) / (total words in scope)
            const learnedCount = matchesCurrentSelection.filter(v => {
                const status = learningStatus[v['单词'].toLowerCase()];
                return status && (status.status === 'mastered' || status.status === 'learning' || (status.stage !== undefined && status.stage > 0));
            }).length;
            
            const progressPercent = scopeStats.total > 0 ? Math.round((learnedCount / scopeStats.total) * 100) : 0;
            const progressBar = document.getElementById('header-progress-bar');
            const progressText = document.getElementById('header-progress-percent');
            if (progressBar) progressBar.style.width = `${progressPercent}%`;
            if (progressText) progressText.innerText = `${progressPercent}%`;

            // Update Profile Stats (Bottom Bar)
            updateProfileStats();

            // Update "All" button count in Frequency row (Full count for current POS)
            const allInPosScope = allVerbs.filter(v => !excludedVerbs.has(v['单词']) && matchesPos(v, currentPos)).length;
            safeUpdate('count-freq-all', allInPosScope);
            
            // Update Review Badge in bottom nav (Only DUE words)
             const reviewBadge = document.getElementById('nav-review-badge');
             if (reviewBadge) {
                 if (scopeStats.due > 0) {
                     reviewBadge.innerText = scopeStats.due;
                     reviewBadge.classList.remove('hidden');
                 } else {
                     reviewBadge.classList.add('hidden');
                 }
             }
            safeUpdate('count-must', freqCounts.must);
            safeUpdate('count-core', freqCounts.core);
            safeUpdate('count-advanced', freqCounts.advanced);
            safeUpdate('count-basic', freqCounts.basic);
            safeUpdate('count-rare', freqCounts.rare);
            
            return searchMatches; // Return for use in auto-selection
        }

        function renderEbbinghausChart(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Use a stable width and fixed height for the SVG
            const width = container.clientWidth || 320;
            const svgHeight = 200; // Increased height
            const padding = 30; // Increased padding for jitter safety
            const stagesCount = 10; // 0-9
            
            // Colors for each stage: A single professional Blue scale (Light to Deep)
            const stageColors = [
                '#3b82f6', // 0: Blue-500 (Vibrant Blue)
                '#2563eb', // 1: Blue-600
                '#1d4ed8', // 2: Blue-700
                '#1e40af', // 3: Blue-800
                '#1e3a8a', // 4: Blue-900
                '#172554', // 5: Blue-950
                '#0f172a', // 6: Slate-900
                '#020617', // 7: Slate-950
                '#000000', // 8: Black
                '#000000'  // 9: Black (Mastery)
            ];
            
            // Generate curves for the background (Spaced Repetition Concept)
            // Each subsequent curve is "flatter" than the previous one
            const generateCurvePath = (flatness = 3, startY = 0.9) => {
                const points = [];
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    const x = t * (width - 2 * padding) + padding;
                    // Ebbinghaus Forgetting Curve formula: R = e^(-t/S)
                    // We map it to the chart space
                    const yValue = 0.15 + 0.75 * (startY * Math.exp(-t * flatness));
                    const y = svgHeight - padding - (yValue * (svgHeight - 2 * padding));
                    points.push(`${x},${y}`);
                }
                return `M ${points.join(' L ')}`;
            };

            // Main "Mastery" curve: This is the envelope connecting the points of a certain retention level
            // after each review. As stages increase, the retention level "climbs".
            const masteryPoints = [];
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const x = t * (width - 2 * padding) + padding;
                // As stage progress (t) increases, retention (yValue) increases (concave down)
                // Using a learning curve shape: 1 - e^(-kt)
                const yValue = 0.2 + 0.7 * (1 - Math.exp(-t * 3.5)) / (1 - Math.exp(-3.5));
                const y = svgHeight - padding - (yValue * (svgHeight - 2 * padding));
                masteryPoints.push(`${x},${y}`);
            }
            
            // Render individual points for each word
            let pointsHtml = '';
            let stageGuidesHtml = '';
            const stageCounts = new Array(stagesCount).fill(0);
            
            // Generate vertical stage guides (lanes)
            for (let i = 0; i < stagesCount; i++) {
                const t = i / (stagesCount - 1);
                const x = t * (width - 2 * padding) + padding;
                stageGuidesHtml += `
                    <line x1="${x}" y1="${padding}" x2="${x}" y2="${svgHeight - padding}" 
                          stroke="#f1f5f9" stroke-width="1" stroke-dasharray="2,4" />
                    <text x="${x}" y="${svgHeight - padding + 12}" font-size="8" font-weight="800" 
                          fill="#cbd5e1" text-anchor="middle" class="uppercase tracking-tighter">S${i}</text>
                `;
            }
            
            // Only show words that match current selection (POS and Frequency filters)
            const wordsInReview = allVerbs.filter(v => {
                const word = v['单词'].toLowerCase();
                const status = learningStatus[word];
                if (!status || status.status === 'mastered' || status.stage === undefined) return false;
                
                // Match current filters (POS and Frequency)
                if (!matchesPos(v, currentPos)) return false;
                if (!matchesFreq(v, currentFreq)) return false;
                if (excludedVerbs.has(v['单词'])) return false;
                
                return true;
            });

            wordsInReview.forEach((v, index) => {
                const word = v['单词'];
                const status = learningStatus[word.toLowerCase()];
                const stage = Math.min(status.stage, stagesCount - 1);
                stageCounts[stage]++;
                
                const t = stage / (stagesCount - 1);
                const xBase = t * (width - 2 * padding) + padding;
                // Map word position to the Mastery Curve
                const yValue = 0.2 + 0.7 * (1 - Math.exp(-t * 3.5)) / (1 - Math.exp(-3.5));
                const yBase = svgHeight - padding - (yValue * (svgHeight - 2 * padding));
                
                // Add jitter: Reduced X jitter to keep points in their "lanes"
                let hash = 0;
                for (let i = 0; i < word.length; i++) {
                    hash = ((hash << 5) - hash) + word.charCodeAt(i);
                    hash |= 0;
                }
                const jitterX = ((hash % 10) / 10 - 0.5) * 10;
                const jitterY = (((hash >> 4) % 10) / 10 - 0.5) * 25;
                
                // Clamp coordinates to stay within SVG axes (quadrant)
                const x = Math.max(padding + 4, Math.min(width - padding - 4, xBase + jitterX));
                const y = Math.max(padding + 4, Math.min(svgHeight - padding - 4, yBase + jitterY));
                const color = stageColors[stage];
                
                pointsHtml += `
                    <circle cx="${x}" cy="${y}" r="2.2" 
                            fill="${color}"
                            class="cursor-help opacity-95 hover:opacity-100 transition-all hover:r-4"
                            onclick="openVerb('${word}')">
                        <title>${word} | Stage ${stage}</title>
                    </circle>`;
            });
            
            // Generate Legend HTML
            let legendHtml = '<div class="flex flex-wrap justify-center gap-x-4 gap-y-3 mt-4 px-2">';
            stageColors.forEach((color, i) => {
                legendHtml += `
                    <div class="flex items-center gap-1.5">
                        <div class="w-1.5 h-1.5 rounded-full" style="background-color: ${color}"></div>
                        <span class="text-xs font-black text-gray-500 tracking-tight uppercase">S${i} <span class="text-gray-800 font-bold ml-0.5">${stageCounts[i]}</span></span>
                    </div>`;
            });
            legendHtml += '</div>';
            
            container.innerHTML = `
                <div class="relative animate-fade-in">
                    <svg width="${width}" height="${svgHeight}" viewBox="0 0 ${width} ${svgHeight}" class="overflow-visible">
                        <defs>
                            <linearGradient id="curveGradient" x1="0%" y1="100%" x2="0%" y2="0%">
                                <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.01" />
                                <stop offset="100%" stop-color="#3b82f6" stop-opacity="0.1" />
                            </linearGradient>
                        </defs>
                        
                        <!-- Y-Axis Label -->
                        <text x="${padding - 15}" y="${padding}" font-size="9" font-weight="900" fill="#94a3b8" transform="rotate(-90, ${padding - 15}, ${padding})" text-anchor="end" class="uppercase tracking-widest opacity-80">Retention</text>
                        
                        <!-- X-Axis Label -->
                        <text x="${width - padding}" y="${svgHeight - padding + 22}" font-size="9" font-weight="900" fill="#94a3b8" text-anchor="end" class="uppercase tracking-widest opacity-80">Memory Stages</text>

                        <!-- Area under mastery curve -->
                        <path d="M ${padding},${svgHeight - padding} ${masteryPoints.map(p => 'L ' + p).join(' ')} L ${width - padding},${svgHeight - padding} Z" 
                              fill="url(#curveGradient)" />
                        
                        <!-- Spaced Repetition Background Curves (Faint) -->
                        <path d="${generateCurvePath(4.5, 0.8)}" fill="none" stroke="#f1f5f9" stroke-width="1.5" stroke-dasharray="2,2" opacity="0.6" />
                        <path d="${generateCurvePath(3.0, 0.9)}" fill="none" stroke="#e2e8f0" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.4" />
                        <path d="${generateCurvePath(1.5, 1.0)}" fill="none" stroke="#cbd5e1" stroke-width="1.5" stroke-dasharray="8,4" opacity="0.2" />

                        <!-- Grid Lines -->
                        <line x1="${padding}" y1="${svgHeight - padding}" x2="${width - padding}" y2="${svgHeight - padding}" stroke="#f1f5f9" stroke-width="2" />
                        <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${svgHeight - padding}" stroke="#f1f5f9" stroke-width="2" />
                        
                        <!-- Vertical Stage Guides -->
                        ${stageGuidesHtml}
                        
                        <!-- The Mastery Curve Envelope -->
                        <path d="M ${masteryPoints.join(' L ')}" fill="none" stroke="#3b82f6" stroke-width="2" stroke-dasharray="5,5" opacity="0.3" />
                        
                        <!-- Individual Word Points -->
                        ${pointsHtml}
                    </svg>
                    ${legendHtml}
                </div>
            `;
        }

        function switchPos(pos, triggerUpdate = true) {
            if (pos === 'all') {
                currentPos = ['all'];
            } else {
                // If 'all' was selected, remove it when selecting a specific pos
                if (currentPos.includes('all')) {
                    currentPos = [pos];
                } else {
                    const index = currentPos.indexOf(pos);
                    if (index > -1) {
                        // If only one pos left and we deselect it, switch back to 'all'
                        if (currentPos.length === 1) {
                            currentPos = ['all'];
                        } else {
                            currentPos.splice(index, 1);
                        }
                    } else {
                        // If 'excluded' is selected, it should be the only one
                        if (pos === 'excluded') {
                            currentPos = ['excluded'];
                        } else {
                            // If 'excluded' was selected, remove it when selecting regular pos
                            const exclIndex = currentPos.indexOf('excluded');
                            if (exclIndex > -1) currentPos.splice(exclIndex, 1);
                            currentPos.push(pos);
                        }
                    }
                }
            }
            
            // When switching filters, reset scroll and count in state
            const state = {
                currentPos,
                currentFreq,
                scrollY: 0, 
                displayedCount: 4 
            };
            localStorage.setItem(STATE_KEY, JSON.stringify(state));
            
            document.querySelectorAll('[data-pos]').forEach(btn => {
                if (currentPos.includes(btn.dataset.pos)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            if (triggerUpdate) {
                updateCounts(); 
                
                // Refresh current page
                if (currentPage === 'learn') {
                    applyFilters(true); // User request: "如果改变了词库范围是要自动刷新的"
                } else if (currentPage === 'review') {
                    renderReviewPage();
                } else if (currentPage === 'mastery') {
                    renderMasteryPage();
                }
                
                updateProfileStats(); // Sync profile stats immediately
            }
        }

        function switchFreq(freq, triggerUpdate = true) {
            if (freq === 'all') {
                currentFreq = ['all'];
            } else {
                // If 'all' was selected, remove it when selecting a specific freq
                if (currentFreq.includes('all')) {
                    currentFreq = [freq];
                } else {
                    const index = currentFreq.indexOf(freq);
                    if (index > -1) {
                        // If only one freq left and we deselect it, switch back to 'all'
                        if (currentFreq.length === 1) {
                            currentFreq = ['all'];
                        } else {
                            currentFreq.splice(index, 1);
                        }
                    } else {
                        currentFreq.push(freq);
                    }
                }
            }
            
            // When switching filters, reset scroll and count in state
            const state = {
                currentPos,
                currentFreq,
                scrollY: 0, 
                displayedCount: 4 
            };
            localStorage.setItem(STATE_KEY, JSON.stringify(state));
            
            document.querySelectorAll('[data-freq]').forEach(btn => {
                if (currentFreq.includes(btn.dataset.freq)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            if (triggerUpdate) {
                updateCounts(); 
                
                // Refresh current page
                if (currentPage === 'learn') {
                    applyFilters(true); // User request: "如果改变了词库范围是要自动刷新的"
                } else if (currentPage === 'review') {
                    renderReviewPage();
                } else if (currentPage === 'mastery') {
                    renderMasteryPage();
                }
                
                updateProfileStats(); // Sync profile stats immediately
            }
        }

        function applyFilters(force = false) {
            const query = document.getElementById('searchInput').value;
            const isSearching = query.length > 0;
            
            displayedVerbs = allVerbs.filter(v => {
                const verbKey = v['单词'].toLowerCase();
                const status = learningStatus[verbKey];
                const matchesSearch = v['单词'].includes(query);
                
                // Exclude verbs that the user has manually excluded
                if (typeof excludedVerbs !== 'undefined' && excludedVerbs.has(v['单词'])) return false;
                
                if (!matchesPos(v, currentPos)) return false;
                
                // Search Filter
                if (!matchesSearch) return false;

                let isFreqMatched = false;
                if (currentFreq.includes('all')) {
                    // For 'all' frequency, we want to allow everything initially
                    isFreqMatched = true;
                } else {
                    isFreqMatched = matchesFreq(v, currentFreq);
                }
                
                if (!isFreqMatched) return false;

                // User request: Learn page default view (no search) should ONLY show Unlearned words.
                // But Search should find EVERYTHING (Unlearned, Learning, Mastered).
                
                const isReviewOrMastered = currentFreq.includes('review') || currentFreq.includes('mastered');
                
                // Only apply strict status filtering if:
                // 1. We are on Learn page
                // 2. We are NOT searching
                // 3. We are NOT explicitly asking for Review/Mastered words
                if (currentPage === 'learn' && !isSearching && !isReviewOrMastered) {
                    // If the word has any status (Learning or Mastered), hide it from the default batch
                    if (status) return false;
                }
                
                return true;
            });

            // User request: For Learn page (when NOT in review/mastered filter), handle persistence and random selection
            const isReviewOrMastered = currentFreq.includes('review') || currentFreq.includes('mastered');
            if (currentPage === 'learn' && !isReviewOrMastered) {
                // If searching, show all matches and don't mess with the batch
                if (isSearching) {
                    // Do nothing to displayedVerbs, let it show all search matches
                } else {
                    // Normal batch logic when not searching
                    const validBatchWords = savedBatch.filter(word => 
                        displayedVerbs.some(v => v['单词'] === word)
                    );

                    // Decision logic:
                    // 1. If we have a valid batch and we are NOT forcing a refresh, keep the batch.
                    if (validBatchWords.length > 0 && !force) {
                        displayedVerbs = displayedVerbs.filter(v => validBatchWords.includes(v['单词']));
                    } 
                    // 2. If we are forcing a refresh OR the current batch is empty, generate a NEW batch.
                    else if (force || validBatchWords.length === 0) {
                        displayedVerbs = displayedVerbs
                            .sort(() => Math.random() - 0.5)
                            .slice(0, 4);
                        
                        // Save new batch
                        const newBatchWords = displayedVerbs.map(v => v['单词']);
                        updateSavedBatch(newBatchWords);
                    }
                }
            }

            renderGrid(true);
        }

        async function renderGrid(reset = false) {
            const grid = document.getElementById('verbsGrid');
            
            if (reset) {
                grid.innerHTML = '';
                offset = 0;
            }

            const slice = displayedVerbs.slice(offset, offset + limit);
            if (slice.length === 0 && offset === 0) {
                 grid.innerHTML = `
                    <div class="col-span-full py-20 text-center animate-fade-in">
                        <div onclick="showAnalytics()" class="neumorphic-btn-sm w-16 h-16 flex items-center justify-center text-blue-500 mx-auto mb-6 cursor-pointer hover:scale-105 active:scale-95 transition-transform">
                            <i class="fas fa-filter text-2xl"></i>
                        </div>
                        <h3 class="text-xl font-black text-gray-700 mb-2">Learn</h3>
                        <p class="text-gray-400 font-bold text-xs mb-8">No words found in this category.</p>
                        <button onclick="switchPos('all'); switchFreq('all');" class="px-6 py-2 rounded-xl bg-blue-50 text-blue-600 text-xs font-bold uppercase tracking-wider hover:bg-blue-100 transition-colors">
                            Reset Filters
                        </button>
                    </div>`;
                 return;
            }

            // Optimization: Pre-check cache for the current batch
            try {
                const verbsToCheck = slice.filter(v => !v.has_cache).map(v => v['单词']);
                if (verbsToCheck.length > 0) {
                    const res = await fetch('/api/check_cache', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ verbs: verbsToCheck })
                    });
                    if (res.ok) {
                        const cachedVerbs = await res.json();
                        cachedVerbs.forEach(verb => {
                            const item = slice.find(v => v['单词'].toLowerCase() === verb.toLowerCase());
                            if (item) item.has_cache = true;
                        });
                    }
                }
            } catch (e) {
                console.error("Cache pre-check failed:", e);
            }

            slice.forEach(item => {
                const card = createVerbCard(item);
                grid.appendChild(card);
            });

            offset += slice.length;
        }

        function createVerbCard(item) {
            const card = document.createElement('div');
            card.id = 'verb-card-' + item['单词'];
            card.className = 'verb-card group relative flex flex-col items-stretch'; 
            
            // Auto-generate image/explanation if missing
            if (!item.image_url && !item.has_cache) {
                addToQueue(item['单词']);
            }
            
            // Long Press Logic for Exclude (Learn page only)
            let longPressTimer;
            let isLongPress = false;
            let startX = 0;
            let startY = 0;
            const longPressDuration = 600;

            const startLongPress = (e) => {
                // User request: Different pages have different card interactions
                if (currentPage !== 'learn' && currentPage !== 'mastery' && currentPage !== 'review') return;
                
                isLongPress = false;
                
                // Track start position
                if (e.type === 'touchstart') {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                } else {
                    startX = e.clientX;
                    startY = e.clientY;
                }
                
                card.style.transform = 'scale(0.98)';
                card.style.transition = 'transform 0.6s ease';
                
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    if (window.navigator.vibrate) window.navigator.vibrate(50); // Haptic feedback
                    
                    showExcludeOverlay(card, item['单词']);
                    card.style.transform = '';
                }, longPressDuration);
            };

            const cancelLongPress = () => {
                clearTimeout(longPressTimer);
                if (!isLongPress) card.style.transform = '';
            };

            const handleTouchMove = (e) => {
                if (!longPressTimer) return;
                
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                
                // If moved more than 10px, cancel long press
                if (Math.abs(currentX - startX) > 10 || Math.abs(currentY - startY) > 10) {
                    cancelLongPress();
                }
            };

            card.onmousedown = startLongPress;
            card.ontouchstart = startLongPress;
            card.onmouseup = cancelLongPress;
            card.onmouseleave = cancelLongPress;
            card.ontouchend = cancelLongPress;
            card.ontouchcancel = cancelLongPress; // Add touchcancel handler
            card.ontouchmove = handleTouchMove;
            card.oncontextmenu = (e) => {
                if (currentPage === 'learn' || currentPage === 'mastery') e.preventDefault();
            };

            card.onclick = (e) => {
                const overlay = card.querySelector('.exclude-overlay');
                if (overlay && overlay.classList.contains('active')) {
                    isLongPress = false;
                    return;
                }
                
                if (isLongPress) {
                    isLongPress = false;
                    return;
                }
                if (e.target.closest('button') || e.target.closest('.exclude-overlay')) return;
                let isReview = currentFreq === 'review' || currentPage === 'review';
                // User request: Library tab in Review page should show study mode (no spelling test)
                if (currentPage === 'review' && currentReviewTab === 'library') {
                    isReview = false;
                }
                openVerb(item['单词'], isReview);
            };
            
            let refreshBtn = '';
            /* Refresh button removed per user request
            if (item.has_cache) {
                refreshBtn = `
                    <button 
                        onclick="refreshFromCard(event, '${item['单词']}')"
                        class="absolute bottom-2 right-2 w-8 h-8 rounded-full bg-white/90 hover:bg-white text-blue-500 hover:text-blue-600 flex items-center justify-center opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all shadow-sm z-10 border border-blue-100"
                        title="Refresh explanation"
                    >
                        <i class="fas fa-sync-alt text-xs"></i>
                    </button>
                `;
            }
            */

            // Exclude / Restore Status
            const isExcluded = excludedVerbs.has(item['单词']);
            const excludedClass = isExcluded ? 'text-red-400' : 'text-gray-700 verb-title-text';
            const animClass = isExcluded ? 'strike-anim active' : 'strike-anim';

            let imageHtml = '';
            let contentClasses = 'verb-content verb-card-block flex-1 flex flex-col items-center px-3 pt-3 pb-2 min-h-[100px] transition-all duration-200';
            
            // Check image provider setting
            const appSettings = JSON.parse(localStorage.getItem('app_settings') || '{}');
            const imageProvider = appSettings.image_provider || 'dicebear';
            
            if (imageProvider === 'none') {
                imageHtml = `
                <div class="verb-image-container verb-card-block w-full h-32 overflow-hidden relative shrink-0 transition-all duration-200">
                    <div class="frosted-placeholder">
                        <i class="fas fa-image"></i>
                    </div>
                    <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>
                </div>`;
                contentClasses += ' justify-start pt-2';
            } else if (item.image_url) {
                imageHtml = `
                <div class="verb-image-container verb-card-block w-full h-32 overflow-hidden relative shrink-0 transition-all duration-200">
                    <img src="/api/image/${encodeURIComponent(item['单词'])}" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" alt="${item['单词']}" loading="lazy" onerror="showFrostedPlaceholder(this)">
                    <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>
                </div>`;
                contentClasses += ' justify-start pt-2';
            } else {
                contentClasses += ' justify-center';
            }

            // Ebbinghaus Status
            const status = learningStatus[item['单词'].toLowerCase()];
            let ebbinghausBadge = '';
            if (status) {
                const isMastered = status.status === 'mastered';
                const isDue = new Date(status.next_review) <= new Date() && !isMastered;
                
                let dueClass = '';
                let dueIcon = '';
                let label = `Stage ${status.stage}`;

                if (isMastered) {
                    dueClass = 'bg-green-500 text-white';
                    dueIcon = '<i class="fas fa-trophy mr-1"></i>';
                    label = 'Mastered';
                } else if (isDue) {
                    dueClass = 'bg-orange-500 text-white animate-pulse';
                    dueIcon = '<i class="fas fa-clock mr-1"></i>';
                    label = 'Review Now';
                } else {
                    dueClass = 'bg-blue-500 text-white';
                    dueIcon = '<i class="fas fa-hourglass-half mr-1"></i>';
                    
                    // Show time remaining
                    const diff = new Date(status.next_review) - new Date();
                    const mins = Math.ceil(diff / 60000);
                    if (mins < 60) label = `${mins}m`;
                    else if (mins < 1440) label = `${Math.round(mins/60)}h`;
                    else label = `${Math.round(mins/1440)}d`;
                }

                ebbinghausBadge = `
                    <div class="absolute top-2 left-2 z-10 flex flex-col gap-0.5 pointer-events-none">
                        <div class="px-2 py-0.5 rounded-lg text-[10px] font-black uppercase tracking-wider flex items-center shadow-sm ${dueClass}">
                            ${dueIcon}<span>${label}</span>
                        </div>
                        ${!isMastered ? `
                        <div class="w-full h-1.5 bg-black/10 rounded-full overflow-hidden shadow-[inset_0_1px_2px_rgba(0,0,0,0.1)]">
                            <div class="h-full ${isDue ? 'bg-orange-400' : 'bg-blue-400'} transition-all duration-500" style="width: ${(status.stage / 8) * 100}%"></div>
                        </div>
                        ` : ''}
                    </div>
                `;
            }

            const excludeOverlay = `
                <div class="exclude-overlay p-4" onclick="hideExcludeOverlay(this)">
                    <div class="w-full max-w-[150px] space-y-3">
                        <button class="mastery-confirm-btn text-orange-600">
                            <i class="fas fa-trophy text-sm"></i>
                            <span class="whitespace-nowrap">Mark Mastered</span>
                        </button>
                        <button class="exclude-confirm-btn text-gray-500">
                            <i class="fas fa-eye-slash text-sm"></i>
                            <span class="whitespace-nowrap">Confirm Exclude</span>
                        </button>
                        <div class="text-gray-400 text-[9px] font-bold uppercase tracking-wider text-center pt-1 opacity-60">Click outside to cancel</div>
                    </div>
                </div>
            `;

            // Page-specific Context Indicator
            let contextIcon = '';
            if (currentPage === 'mastery') {
                contextIcon = '<i class="fas fa-trophy text-green-500 opacity-30 text-xs"></i>';
            } else if (currentPage === 'review') {
                contextIcon = '<i class="fas fa-graduation-cap text-blue-500 opacity-30 text-xs"></i>';
            } else if (currentPage === 'learn') {
                contextIcon = '<i class="fas fa-seedling text-indigo-500 opacity-30 text-xs"></i>';
            }
            const contextIndicator = contextIcon ? `<div class="absolute bottom-2.5 left-2.5 pointer-events-none">${contextIcon}</div>` : '';

            card.innerHTML = `
                ${excludeOverlay}
                ${ebbinghausBadge}
                ${imageHtml}
                <div class="${contentClasses} relative">
                    <h3 class="${item['单词'].length > 12 ? 'text-base' : item['单词'].length > 8 ? 'text-lg' : 'text-xl'} font-black mb-1 transition-colors select-none ${excludedClass} ${animClass} tracking-tight text-center w-full break-words leading-tight">
                        ${item['单词']}
                    </h3>
                    <div class="flex items-center justify-center gap-1.5 mb-1">
                        <span class="text-[10px] px-2 py-0.5 rounded-lg ${getProbabilityColor(item['词频'])} font-black uppercase tracking-wider border border-white/20 shadow-sm">
                            ${calculateExamProbability(item['词频'])}% Freq
                        </span>
                    </div>
                    
                    <div class="w-full flex items-center justify-between mt-auto pt-0.5">
                        <div class="w-6 flex justify-start">${contextIcon}</div>
                        <p class="text-xs leading-relaxed text-gray-500 text-center font-medium truncate px-1 flex-1" title="${item['释义'] || ''}">${item['释义'] || ''}</p>
                        <div class="w-6 flex justify-end text-gray-300 text-[10px] font-black tracking-tighter pointer-events-none">#${item['序号']}</div>
                    </div>
                </div>
                ${refreshBtn}
            `;
            return card;
        }

        // Helper for image placeholders
        function showFrostedPlaceholder(imgElement) {
            const placeholder = document.createElement('div');
            placeholder.className = 'frosted-placeholder';
            placeholder.innerHTML = '<i class="fas fa-image"></i>';
            imgElement.replaceWith(placeholder);
        }

        function showExcludeOverlay(card, word) {
            const overlay = card.querySelector('.exclude-overlay');
            if (overlay) {
                const masteryBtn = overlay.querySelector('.mastery-confirm-btn');
                const excludeBtn = overlay.querySelector('.exclude-confirm-btn');
                
                if (currentPage === 'mastery') {
                    // Mastery Page: Only "Reset to Review"
                    if (masteryBtn) masteryBtn.style.display = 'none';
                    excludeBtn.innerHTML = '<i class="fas fa-history text-sm"></i> <span>Confirm Reset</span>';
                    excludeBtn.classList.remove('text-gray-500');
                    excludeBtn.classList.add('text-blue-600');
                    excludeBtn.onclick = (e) => resetToReview(e, word);
                } else {
                    // Learn Page or Review Library: "Mark as Mastered" and "Exclude"
                    if (masteryBtn) {
                        masteryBtn.style.display = 'flex';
                        masteryBtn.innerHTML = '<i class="fas fa-trophy text-sm"></i> <span>Mark Mastered</span>';
                        masteryBtn.onclick = (e) => confirmMastery(e, word);
                    }
                    excludeBtn.innerHTML = '<i class="fas fa-eye-slash text-sm"></i> <span>Confirm Exclude</span>';
                    excludeBtn.classList.remove('text-blue-600');
                    excludeBtn.classList.add('text-gray-500');
                    excludeBtn.onclick = (e) => confirmExclude(e, word);
                }
                overlay.classList.add('active');
            }
        }

        async function confirmMastery(event, word) {
            event.stopPropagation();
            const card = document.getElementById('verb-card-' + word);
            if (card) {
                card.classList.add('card-fade-out');
                try {
                    const res = await fetch('/api/mastery', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ verb: word, result: 'mastered' })
                    });
                    
                    if (res.ok) {
                        const result = await res.json();
                        // Update local status
                        learningStatus[word.toLowerCase()] = {
                            status: 'mastered',
                            stage: result.new_stage,
                            next_review: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString()
                        };
                        
                        setTimeout(() => {
                            // Update batch and counts
                            if (currentPage === 'learn') {
                                updateSavedBatch(word);
                                displayedVerbs = displayedVerbs.filter(v => v['单词'].toLowerCase() !== word.toLowerCase());
                            } else if (currentPage === 'review') {
                                renderReviewPage();
                            }
                            card.remove();
                            updateCounts();
                            updateProfileStats();
                            
                            if (currentPage === 'learn' && displayedVerbs.length === 0) {
                                applyFilters();
                            }
                        }, 400);
                    }
                } catch (e) {
                    console.error("Error marking as mastered:", e);
                    card.classList.remove('card-fade-out');
                }
            }
        }

        async function resetToReview(event, word) {
            event.stopPropagation();
            const card = document.getElementById('verb-card-' + word);
            if (card) {
                card.classList.add('card-fade-out');
                try {
                    // Call backend to reset to stage 0
                    const res = await fetch('/api/ebbinghaus/record', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ verb: word, result: 'forgotten' })
                    });
                    
                    if (res.ok) {
                        // Update local status
                        const result = await res.json();
                        learningStatus[word.toLowerCase()] = {
                            status: 'learning',
                            stage: 0,
                            next_review: result.next_review
                        };
                        
                        setTimeout(() => {
                            renderMasteryPage(); // Refresh the grid
                        }, 300);
                    }
                } catch (e) {
                    console.error("Error resetting word:", e);
                    card.classList.remove('card-fade-out');
                }
            }
        }

        function hideExcludeOverlay(overlay) {
            if (overlay) {
                overlay.classList.remove('active');
                // Ensure isLongPress is reset to allow clicking card details after canceling
                const card = overlay.parentElement;
                if (card) {
                    // We don't have direct access to isLongPress here as it's scoped to createVerbCard
                    // but we can trigger a cleanup by setting isLongPress=false in onclick later
                }
            }
        }

        function confirmExclude(event, word) {
            event.stopPropagation();
            const card = document.getElementById('verb-card-' + word);
            if (card) {
                card.classList.add('card-fade-out');
                setTimeout(() => {
                    excludedVerbs.add(word);
                    // Also save exclusion to localStorage immediately
                    localStorage.setItem('excludedVerbs', JSON.stringify([...excludedVerbs]));
                    
                    // Sync to server
                    fetch('/api/exclude', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ verb: word, exclude: true })
                    }).catch(e => console.error("Failed to sync exclusion to server", e));

                    // Update batch
                    if (currentPage === 'learn') {
                        updateSavedBatch(word);
                        displayedVerbs = displayedVerbs.filter(v => v['单词'].toLowerCase() !== word.toLowerCase());
                    } else if (currentPage === 'review') {
                        renderReviewPage();
                    } else if (currentPage === 'mastery') {
                        renderMasteryPage();
                    }

                    card.remove();
                    updateCounts();
                    updateProfileStats();
                    
                    // If no more cards in Learn, trigger a refresh
                    if (currentPage === 'learn' && displayedVerbs.length === 0) {
                        applyFilters();
                    }
                }, 400);
            }
        }

        function loadMoreVerbs() {
            if (offset < displayedVerbs.length) {
                renderGrid(false);
            }
        }

        function filterVerbs() {
            updateCounts();
            
            // Refresh current page
            if (currentPage === 'learn') {
                applyFilters();
            } else if (currentPage === 'review') {
                renderReviewPage();
            } else if (currentPage === 'mastery') {
                renderMasteryPage();
            }
            
            updateProfileStats(); // Sync profile stats immediately
        }

        // Excluded Words Logic
        function toggleExclude(event, word) {
            // Stop propagation to prevent opening the card
            if (event) event.stopPropagation();
            
            const target = event.target;
            const card = document.getElementById('verb-card-' + word);
            
            // Check if we are currently excluded
            const isCurrentlyExcluded = excludedVerbs.has(word);
            
            if (isCurrentlyExcluded) {
                // RESTORE action
                // 1. Start reverse strikethrough animation (Left to Right disappearance)
                // Remove .active (width 100%) and add .removing (anchors right, width 0%)
                target.classList.add('removing');
                target.classList.remove('active');
                
                // Color change: wait for line to disappear
                setTimeout(() => {
                    target.classList.remove('removing'); // Cleanup
                    target.classList.remove('text-red-400');
                    target.classList.add('text-gray-700');
                    target.classList.add('group-hover:text-blue-600'); // Restore hover effect
                }, 400);

                // If in Excluded tab, fade out the card because it's leaving the list
                if (currentPos === 'excluded') {
                    if (card) {
                        // 2. Wait for strikethrough removal (400ms) then fade out card
                        setTimeout(() => {
                            // Start fade out
                            card.classList.add('card-fade-out');
                            
                            // 3. Wait for fade out (400ms) then update data
                            setTimeout(() => {
                                 excludedVerbs.delete(word);
                                 finishToggle();
                            }, 400); 
                        }, 400);
                    } else {
                        excludedVerbs.delete(word);
                        finishToggle();
                    }
                } else {
                    // Not in excluded tab (shouldn't happen usually as excluded items are hidden elsewhere)
                    excludedVerbs.delete(word);
                    finishToggle();
                }
            } else {
                // EXCLUDE action
                // 1. Start strikethrough animation
                target.classList.add('active');
                target.classList.add('text-red-400');
                target.classList.remove('text-gray-700');
                target.classList.remove('group-hover:text-blue-600'); // Remove hover effect to keep red color
                
                // 2. Wait for strikethrough (400ms) then fade out card
                setTimeout(() => {
                    if (card) {
                        card.classList.add('card-fade-out');
                    }
                    
                    // 3. Wait for fade out (400ms) then update data
                    setTimeout(() => {
                        excludedVerbs.add(word);
                        finishToggle();
                    }, 400);
                    
                }, 400);
            }
            
            async function finishToggle() {
                // Save to LocalStorage
                localStorage.setItem('excludedVerbs', JSON.stringify([...excludedVerbs]));
                
                // Sync to Server
                try {
                    await fetch('/api/exclude', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ verb: word, exclude: !isCurrentlyExcluded })
                    });
                } catch (e) {
                    console.error("Failed to sync exclusion to server", e);
                }

                // Refresh view
                updateCounts();
                applyFilters();
                updateProfileStats();
                renderExcludedVerbs(); // Update badge and modal list
            }
        }

        // Probability Calculation Logic
        function updateKaoyanCountdown() {
            const countdownEl = document.getElementById('kaoyan-countdown');
            const roundsEl = document.getElementById('learning-rounds');
            if (!countdownEl || !roundsEl) return;

            // Target date: 2026-12-19 (Approximate date for 2027 Kaoyan)
            const targetDate = new Date('2026-12-19T08:30:00');
            const now = new Date();
            const diff = targetDate - now;

            if (diff <= 0) {
                countdownEl.innerText = "0";
            } else {
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                countdownEl.innerText = days;
            }

            // Calculate rounds: (Learned words / Total words)
            const totalWords = allVerbs.length || 5500; // Fallback to 5500 if not loaded
            const learnedWords = Object.keys(learningStatus).filter(k => learningStatus[k].stage > 0).length;
            // Increased precision to 3 decimal places to show incremental progress
            const rounds = (learnedWords / totalWords).toFixed(3);
            roundsEl.innerText = rounds;
        }

        // Auto-update countdown and rounds every minute
        setInterval(async () => {
            // Fetch latest status to keep "Rounds" in sync across tabs/devices
            if (typeof loadLearningStatus === 'function') {
                await loadLearningStatus();
            }
            updateKaoyanCountdown();
            // Also update profile stats if we are on that tab
            if (typeof updateProfileStats === 'function') {
                updateProfileStats();
            }
        }, 60000);

        // Also update when tab becomes visible again
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
                if (typeof loadLearningStatus === 'function') {
                    await loadLearningStatus();
                }
                updateKaoyanCountdown();
                if (typeof updateProfileStats === 'function') {
                    updateProfileStats();
                }
            }
        });

        // Based on user input: Total frequency is from 200 exam papers.
        // We calculate the probability of a word appearing at least once in a single paper.
        // Model: Poisson Distribution
        // New algorithm: Log-based importance score with saturation threshold
        // Saturation threshold: words with freq >= 4000 are considered 99.9% essential
        function calculateExamProbability(freq) {
            if (!freq) return 0;
            const f = parseInt(freq);
            if (isNaN(f) || f <= 0) return 0;
            
            const saturationThreshold = 4000;
            const logFreq = Math.log(f);
            const maxLog = Math.log(saturationThreshold);
            
            let prob = (logFreq / maxLog) * 100;
            prob = Math.min(99.9, Math.max(1, prob));
            
            return prob.toFixed(1);
        }

        function getProbabilityColor(freq) {
            const prob = calculateExamProbability(freq);
            if (prob >= 80) return "bg-red-100 text-red-600 border border-red-200"; // High probability
            if (prob >= 60) return "bg-orange-100 text-orange-600 border border-orange-200"; // Medium-High
            if (prob >= 40) return "bg-yellow-100 text-yellow-600 border border-yellow-200"; // Medium
            if (prob >= 20) return "bg-blue-100 text-blue-600 border border-blue-200"; // Low-Medium
            return "bg-gray-100 text-gray-500 border border-gray-200"; // Low
        }

        // Modal & Analysis Logic
        const modal = document.getElementById('learningModal');
        const modalTitle = document.getElementById('modalTitle');
        const outputContainer = document.getElementById('outputContainer');
        const essenceContainer = document.getElementById('essenceContainer');
        // const loader = document.getElementById('loader');

        function openVerb(verb, isReview = false, refresh = false) {
            if (!modal.classList.contains('active')) {
                pushModalState(closeModal);
                modal.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent background scroll
            }
            modalTitle.innerText = verb;
            isReviewMode = isReview;
            spellingWord = verb;
            const status = learningStatus[verb.toLowerCase()];

            // Show Ebbinghaus Stage immediately
            const stageBadge = document.getElementById('modalStageBadge');
            if (status && stageBadge) {
                stageBadge.innerText = `Stage ${status.stage}${status.status === 'mastered' ? ' (Mastered)' : ''}`;
                stageBadge.classList.remove('hidden');
                if (status.status === 'mastered') {
                    stageBadge.classList.remove('bg-blue-100', 'text-blue-600');
                    stageBadge.classList.add('bg-green-100', 'text-green-600');
                } else {
                    stageBadge.classList.remove('bg-green-100', 'text-green-600');
                    stageBadge.classList.add('bg-blue-100', 'text-blue-600');
                }
            } else if (stageBadge) {
                stageBadge.classList.add('hidden');
            }

            // Handle Review Mode class for UI hiding
            // Only apply is-review-mode (which causes blur) if isReviewMode is explicitly true
            if (isReviewMode) {
                modal.classList.add('is-review-mode');
                document.getElementById('studyModeControls')?.classList.add('hidden');
                document.getElementById('reviewModeControls')?.classList.remove('hidden');
            } else {
                modal.classList.remove('is-review-mode');
                
                // User request: In Review Library, we don't need "MARK AS LEARNED" because it's already learned.
                // We only show "MARK AS LEARNED" if the word is truly new (stage 0) AND we are NOT on the Review page.
                const isNewWord = !status || status.stage === 0;
                if (isNewWord && currentPage !== 'review') {
                    document.getElementById('studyModeControls')?.classList.remove('hidden');
                } else {
                    document.getElementById('studyModeControls')?.classList.add('hidden');
                }
                
                document.getElementById('reviewModeControls')?.classList.add('hidden');
            }

            // Refresh Button visibility logic
            // Hide refresh button if in Review Session mode OR if Analysis Mode is Manual
            const refreshBtn = document.querySelector('#learningModal button[onclick="refreshExplanation()"]');
            if (refreshBtn) {
                if (isReviewMode || analysisMode === 'manual') {
                    refreshBtn.style.display = 'none';
                } else {
                    refreshBtn.style.display = ''; // Reset to default
                }
            }

            // Show/Hide Review Controls (the bottom buttons like "Mark as Learned" or "Already Mastered")
            const controls = document.getElementById('reviewControls');
            if (controls) {
                const now = new Date();
                const isDue = status && new Date(status.next_review) <= now && status.status !== 'mastered';
                
                // Show controls if:
                // 1. It's due for review
                // 2. We are explicitly in review session mode
                // 3. It's a brand new word (no status) on Learn page
                // 4. We are on the Review page (Review Now tab)
                // BUT only if we are NOT in Library/Mastery/Search results
                const isMasteryPage = currentPage === 'mastery';
                const isReviewLibrary = currentPage === 'review' && currentReviewTab === 'library';
                
                if (!isMasteryPage && !isReviewLibrary && (isDue || isReviewMode || (!status && currentPage === 'learn') || (currentPage === 'review' && currentReviewTab === 'session'))) {
                    controls.classList.remove('hidden');
                } else {
                    controls.classList.add('hidden');
                }
            }
            
            // Multiple calls to handle different stages of modal expansion
            adjustModalTitleFontSize();
            setTimeout(adjustModalTitleFontSize, 50);
            setTimeout(adjustModalTitleFontSize, 150);
            setTimeout(adjustModalTitleFontSize, 300);
            
            // Save active verb to state
            try {
                const savedState = localStorage.getItem(STATE_KEY);
                const state = savedState ? JSON.parse(savedState) : {};
                state.activeVerb = verb;
                state.isReviewMode = isReviewMode;
                localStorage.setItem(STATE_KEY, JSON.stringify(state));
            } catch (e) {}

            // Decision: Auto analyze or manual?
            if (refresh) {
                // Force refresh always triggers analysis
                analyzeVerbs(verb, refresh);
            } else if (analysisMode === 'auto') {
                // Standard Auto Mode: Try cache, if missing generate new
                analyzeVerbs(verb, false);
            } else if (analysisMode === 'cache_only') {
                // In Strict Cache Only mode, we now rely on the backend's "strict_cache" flag.
                // We attempt to load via API. 
                // If backend has cache (SQLite), it returns it.
                // If backend has NO cache, it returns empty (due to strict_cache=true), 
                // and analyzeVerbs handles showing the manual trigger.
                analyzeVerbs(verb, false);
            } else {
                // Manual Mode: Always manual trigger
                showManualTrigger(verb);
            }
        }

        // Deprecated: No longer used as primary check, logic moved to analyzeVerbs + backend flag
        async function checkDbAndDecide(verb) {
             // ... kept for reference or legacy calls ...
             // But for now we just redirect to analyzeVerbs with strict mode logic implicitly handled there
             // actually we can just return since it's not called anymore
             console.warn("checkDbAndDecide is deprecated.");
        }

        function showManualTrigger(verb, titleOverride = null) {
            // Hide progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) progressContainer.classList.add('hidden');

            const title = titleOverride || 'AI Analysis Disabled';
            let subtext = '';
            
            if (titleOverride === 'Cache Not Found') {
                subtext = 'This word is not in local cache.<br>Click below to generate new AI analysis.';
            } else {
                subtext = 'Auto-analysis is turned off. Click the button below<br>to start deep analysis for this word.';
            }

            // Set content to show a manual "Start Analysis" button
            const outputContainer = document.getElementById('outputContainer');
            if (outputContainer) {
                const iconClass = titleOverride === 'Cache Not Found' ? 'database' : 'robot';
                
                outputContainer.innerHTML = `
                    <div class="absolute inset-0 flex flex-col items-center justify-center p-8 text-center space-y-6">
                        <div class="w-24 h-24 rounded-3xl neumorphic flex items-center justify-center text-indigo-400 mb-2">
                            <i class="fas fa-${iconClass} text-4xl"></i>
                        </div>
                        <div>
                            <h3 class="text-xl font-black text-gray-700 mb-1 uppercase tracking-tight">${title}</h3>
                            <p class="text-[10px] text-gray-400 font-bold uppercase tracking-widest leading-relaxed">
                                ${subtext}
                            </p>
                        </div>
                        <button onclick="triggerAnalysis('${verb}')" class="neumorphic-btn px-10 py-4 text-indigo-600 font-black text-xs uppercase tracking-[0.2em] hover:scale-105 active:scale-95 transition-all flex items-center gap-3">
                            <i class="fas fa-bolt text-indigo-400"></i>
                            Generate with AI
                        </button>
                    </div>
                `;
            }
        }

        // New wrapper to trigger analysis from manual button
        function triggerAnalysis(verb) {
            // Restore refresh button if needed (e.g., if user manually starts it)
            const refreshBtn = document.querySelector('#learningModal button[onclick="refreshExplanation()"]');
            if (refreshBtn && !isReviewMode) {
                refreshBtn.style.display = ''; 
            }
            
            analyzeVerbs(verb);
        }

        let isClosing = false;

        function closeModal(fromPopState = false) {
            if (isClosing) return;
            isClosing = true;

            if (fromPopState !== true) {
                // If closed manually (not via back button), remove the state from history
                // const idx = modalStack.indexOf(closeModal);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }

            // Abort any ongoing analysis request
            if (analyzeController) {
                analyzeController.abort();
                analyzeController = null;
            }

            // Start hiding the modal immediately
            modal.classList.remove('active');
            document.body.style.overflow = ''; // Restore background scroll
            
            // Remove active verb from state immediately
            try {
                const savedState = localStorage.getItem(STATE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    delete state.activeVerb;
                    delete state.isReviewMode;
                    localStorage.setItem(STATE_KEY, JSON.stringify(state));
                }
            } catch (e) {}
            
            // Wait for modal fade-out transition before resetting internal state
            // This prevents "flashing" of content as modes change
            setTimeout(() => {
                // Now it's safe to remove mode classes and reset flags
                modal.classList.remove('peek-active'); 
                modal.classList.remove('is-review-mode');
                isReviewMode = false;
                currentCardIndex = 0;
                spellingWord = '';

                // Clear content
                outputContainer.innerHTML = `
                    <div id="progressContainer" class="hidden absolute inset-0 flex flex-col items-center justify-center z-10 bg-[#e0e5ec]/80 backdrop-blur-sm">
                        <div class="w-64 md:w-80 bg-gray-300 rounded-full h-4 overflow-hidden shadow-inner">
                            <div id="progressBar" class="bg-blue-500 h-full rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
                        </div>
                        <p id="progressText" class="mt-4 text-gray-600 font-semibold animate-pulse">Initializing analysis...</p>
                    </div>
                `;
                const essenceWrapper = document.getElementById('essenceContentWrapper');
                if (essenceWrapper) essenceWrapper.innerHTML = '';
                essenceContainer.classList.add('hidden');
                
                isClosing = false;
            }, 300);
        }

        async function checkSpelling(input) {
            const container = document.getElementById('spellingContainer');
            const feedback = document.getElementById('spellingFeedback');
            const inputEl = document.getElementById('spellingInput');
            
            if (!container || !feedback || !inputEl) return;
            
            const isCorrect = input.trim().toLowerCase() === spellingWord.toLowerCase();
            
            if (isCorrect) {
                // Success feedback
                container.classList.add('success-pulse');
                feedback.innerText = 'CORRECT! WELL DONE.';
                feedback.className = 'text-[10px] font-bold h-4 transition-all opacity-100 text-green-500 mt-2';
                inputEl.classList.add('border-2', 'border-green-400');
                
                // Record success to backend (auto-advances stage)
                try {
                    await recordReview('remembered');
                    
                    // Don't close immediately if we are in review mode (recordReview will handle switching)
                } catch (e) {
                    console.error('Failed to record review:', e);
                }
            } else {
                // Error feedback
                container.classList.add('shake');
                feedback.innerText = 'INCORRECT. TRY AGAIN!';
                feedback.className = 'text-[10px] font-bold h-4 transition-all opacity-100 text-red-500 mt-2';
                inputEl.classList.add('border-2', 'border-red-400');
                
                // Remove shake class after animation finishes so it can be re-triggered
                setTimeout(() => {
                    container.classList.remove('shake');
                    inputEl.classList.remove('border-2', 'border-red-400');
                }, 400);
            }
        }

        async function resetToLearn() {
            const verb = document.getElementById('modalTitle').innerText.toLowerCase();
            if (!verb) return;

            // Use custom modal instead of system confirm
            const resetModal = document.getElementById('resetModal');
            const resetVerbName = document.getElementById('resetVerbName');
            const confirmBtn = document.getElementById('confirmResetBtn');
            
            if (resetModal && resetVerbName && confirmBtn) {
                resetVerbName.innerText = verb;
                resetModal.classList.remove('hidden');
                resetModal.classList.add('opacity-100');
                resetModal.querySelector('div').classList.remove('scale-95');
                resetModal.querySelector('div').classList.add('scale-100');
                
                confirmBtn.onclick = async () => {
                    try {
                        const res = await fetch('/api/ebbinghaus/reset', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ verb: verb }) // Correctly pass object with 'verb' key
                        });
                        
                        if (res.ok) {
                            // Close modal first
                            resetModal.classList.add('hidden');
                            
                            // IMMEDIATE: Reset any pressed buttons
                            if (window.globalResetPressedState) window.globalResetPressedState();
                            
                            // Then update state
                            await loadLearningStatus();
                            // Update counts in header if function exists
                            if (typeof updateCounts === 'function') updateCounts();
                            
                            // Close the detail modal
                            closeModal();
                            
                            // Re-render grid to reflect changes
                            if (typeof renderGrid === 'function') renderGrid();
                        }
                    } catch (e) {
                        console.error('Failed to reset word:', e);
                        resetModal.classList.add('hidden');
                    }
                };
            }
        }

        function adjustModalTitleFontSize() {
            const title = document.getElementById('modalTitle');
            if (!title) return;
            
            const container = title.parentElement;
            if (!container) return;

            const update = () => {
                 // 1. Force state for "Natural Width" measurement
                 title.style.fontSize = '1.5rem';
                 title.style.position = 'absolute'; // Break out of flex constraints
                 title.style.width = 'auto';
                 title.style.visibility = 'hidden'; 
                 title.style.flexShrink = '0';
                 
                 requestAnimationFrame(() => {
                     const style = window.getComputedStyle(container);
                     const paddingRight = parseFloat(style.paddingRight) || 0;
                     const paddingLeft = parseFloat(style.paddingLeft) || 0;
                     const availableWidth = container.clientWidth - paddingLeft - paddingRight;
                     
                     if (availableWidth <= 0) {
                         resetTitle();
                         return;
                     }

                     // Now offsetWidth reflects the ACTUAL text width at 1.5rem
                     const naturalWidth = title.offsetWidth;
                     
                     if (naturalWidth > availableWidth) {
                         // 2. Calculate ideal ratio with 2% safety margin (tighter)
                         const ratio = (availableWidth / naturalWidth) * 0.98;
                         let newFontSize = 1.5 * ratio;
                         
                         // 3. Clamp between 0.85rem and 1.5rem (increased minimum for better readability)
                         newFontSize = Math.max(0.85, Math.min(1.5, newFontSize));
                         title.style.fontSize = newFontSize + 'rem';
                     }
                     
                     resetTitle();
                 });
             };
             
             const resetTitle = () => {
                 title.style.position = '';
                 title.style.visibility = '';
                 title.style.width = '';
                 title.style.flexShrink = '';
             };

            // Run on call
            update();
            
            // Re-run if container size changes (e.g. window resize)
            if (!window.titleResizeObserver) {
                window.titleResizeObserver = new ResizeObserver(() => {
                    if (modal.classList.contains('active')) update();
                });
                window.titleResizeObserver.observe(container);
            }
        }

        let analyzeController = null;

        async function analyzeVerbs(verb, refresh = false) {
            // Abort previous request if any AND we are NOT in force-refresh mode
            // Force-refresh (user triggered) should always proceed
            if (analyzeController && !refresh) {
                analyzeController.abort();
            }
            
            const currentController = new AbortController();
            if (!refresh) {
                analyzeController = currentController;
            }

            // Clear image queue if we are refreshing LLM content to prevent mismatch
            if (refresh) {
                imageQueue = imageQueue.filter(v => v !== verb);
            }

            // Get fresh references
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            // Reset Essence
            if (essenceContainer) {
                const essenceWrapper = document.getElementById('essenceContentWrapper');
                if (essenceWrapper) essenceWrapper.innerHTML = '';
                essenceContainer.classList.add('hidden');
            }

            // UI State: Loading
            if (progressContainer) {
                progressContainer.classList.remove('hidden');
                progressBar.style.width = '0%';
                progressText.innerText = refresh ? 'Refreshing explanation...' : 'Searching database...';
            }

            // Start Progress Animation
            let progress = 0;
            const progressInterval = setInterval(() => {
                if (progress < 90) {
                    // Logarithmic-like slowdown
                    const increment = Math.max(0.2, (90 - progress) / 20);
                    progress += increment;
                    if (progressBar) progressBar.style.width = `${progress}%`;
                    
                    if (progressText) {
                        if (refresh) {
                            if (progress > 20 && progress < 50) progressText.innerText = "Forcing new analysis...";
                            else if (progress >= 50 && progress < 80) progressText.innerText = "Consulting AI model...";
                            else if (progress >= 80) progressText.innerText = "Finalizing update...";
                        } else {
                            if (progress > 20 && progress < 50) progressText.innerText = "Analyzing semantic structure...";
                            else if (progress >= 50 && progress < 80) progressText.innerText = "Consulting AI model...";
                            else if (progress >= 80) progressText.innerText = "Finalizing analysis...";
                        }
                    }
                }
            }, 100);

            try {
                // If in Strict Cache Only mode, we now rely on the backend's "strict_cache" flag.
                // We pass this flag to the backend. If backend has data, it returns it.
                // If backend does NOT have data, it will return null/empty (instead of generating AI).
                // This is the most robust way: "Ask backend for cache, but forbid new generation."
                
                const requestPayload = { 
                    verbs: verb, 
                    mode: 'single', 
                    refresh: refresh
                };

                // Add strict_cache flag if needed
                if (analysisMode === 'cache_only' && !refresh) {
                    requestPayload.strict_cache = true;
                }
                
                const response = await fetch('/api/explain', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload),
                    signal: currentController.signal
                });

                const data = await response.json();
                
                // Complete Progress
                clearInterval(progressInterval);
                if (progressBar) progressBar.style.width = '100%';
                if (progressText) progressText.innerText = 'Analysis Complete!';
                
                // Finalize data
                if (analyzeController === currentController) {
                    analyzeController = null;
                }

                // Short delay to show 100%
                await new Promise(r => setTimeout(r, 400));
                
                if (response.ok) {
                    // Check if we got valid content
                    // If strict_cache was true and backend returned no content (or error), data.result might be null/empty
                    if (!data.result || data.result.length < 10) {
                         if (analysisMode === 'cache_only') {
                             // Backend confirmed: No cache available.
                             // Now we show the manual trigger.
                             if (typeof showManualTrigger === 'function') {
                                 showManualTrigger(verb, 'Cache Not Found');
                             } else {
                                 // Fallback if function missing
                                 console.warn("showManualTrigger not found, refreshing...");
                                 // Force refresh
                                 analyzeVerb(verb, false, 'force_refresh');
                             }
                             return;
                         }
                    }

                    // Handle images update
                    if (data.images) {
                        Object.keys(data.images).forEach(verbKey => {
                            const imgUrl = data.images[verbKey];
                            // Update global data
                            const vIndex = allVerbs.findIndex(v => v['单词'].toLowerCase() === verbKey.toLowerCase());
                            if (vIndex !== -1) {
                                allVerbs[vIndex].image_url = imgUrl;
                                allVerbs[vIndex].has_cache = true; // Mark as cached so refresh button shows up
                                
                                // Update DOM if card exists
                                const originalWord = allVerbs[vIndex]['单词'];
                                const card = document.getElementById('verb-card-' + originalWord);
                                
                                const proxyUrl = `/api/image/${encodeURIComponent(originalWord)}?t=${Date.now()}`;
                                
                                if (card) {
                                    // 1. Update image
                                    let imgContainer = card.querySelector('.verb-image-container');
                                    const appSettings = JSON.parse(localStorage.getItem('app_settings') || '{}');
                                    const imageProvider = appSettings.image_provider || 'dicebear';
                                    const isNoneProvider = imageProvider === 'none';

                                    if (!imgContainer) {
                                        let innerHtml = '';
                                        if (isNoneProvider) {
                                            innerHtml = `
                                            <div class="frosted-placeholder">
                                                <i class="fas fa-image"></i>
                                            </div>`;
                                        } else {
                                            innerHtml = `<img src="${proxyUrl}" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" alt="${originalWord}" loading="lazy" onerror="showFrostedPlaceholder(this)">`;
                                        }

                                        const newImgHtml = `
                                    <div class="verb-image-container w-full h-32 overflow-hidden relative shrink-0">
                                        ${innerHtml}
                                        <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>
                                    </div>`;
                                        card.insertAdjacentHTML('afterbegin', newImgHtml);
                                        
                                        const contentWrapper = card.querySelector('.verb-content');
                                        if (contentWrapper) {
                                            contentWrapper.classList.remove('justify-center');
                                            contentWrapper.classList.add('justify-start', 'pt-2');
                                        }
                                    } else {
                                        if (isNoneProvider) {
                                            imgContainer.innerHTML = `
                                            <div class="frosted-placeholder">
                                                <i class="fas fa-image"></i>
                                            </div>
                                            <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>`;
                                        } else {
                                            const img = imgContainer.querySelector('img');
                                            if (img) {
                                                img.src = proxyUrl;
                                                imgContainer.style.display = '';
                                                img.onerror = () => showFrostedPlaceholder(img);
                                            } else {
                                                // Replace placeholder with img if provider changed from none
                                                imgContainer.innerHTML = `
                                                <img src="${proxyUrl}" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" alt="${originalWord}" loading="lazy" onerror="showFrostedPlaceholder(this)">
                                                <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>`;
                                            }
                                        }
                                    }

                                    // 2. Ensure Refresh button is present
                                    if (!card.querySelector('button[onclick*="refreshFromCard"]')) {
                                        const refreshBtnHtml = `
                                            <button 
                                                onclick="refreshFromCard(event, '${originalWord}')"
                                                class="absolute bottom-2 right-2 w-8 h-8 rounded-full bg-white/90 hover:bg-white text-blue-500 hover:text-blue-600 flex items-center justify-center opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all shadow-sm z-10 border border-blue-100"
                                                title="Refresh explanation"
                                            >
                                                <i class="fas fa-sync-alt text-xs"></i>
                                            </button>
                                        `;
                                        card.insertAdjacentHTML('beforeend', refreshBtnHtml);
                                    }
                                }
                            }
                        });
                    }

                    let rawMarkdown = data.result;
                    
                    // Pre-processing: Insert specific delimiters for reliable splitting
                    const SEPARATOR = '|||CARD_SPLIT|||';
                    
                    // 0. Pre-clean BROKEN headers BEFORE splitting logic
                    // This handles weird artifacts like '# # #' or '## # #' which appear in 'be'
                    // We normalize them to standard markdown headers so our split logic works
                    rawMarkdown = rawMarkdown.replace(/(?:^|\n)\s*#\s+#\s+#/g, '\n###'); // '# # #' -> '###'
                    rawMarkdown = rawMarkdown.replace(/(?:^|\n)\s*##\s+#\s+#/g, '\n####'); // '## # #' -> '####'
                    rawMarkdown = rawMarkdown.replace(/(?:^|\n)\s*##\s+#/g, '\n###'); // '## #' -> '###'

                    // 0.1 NORMALIZE ALL HEADERS to #### Key
                    // This is crucial to avoid false positives when splitting.
                    // Instead of splitting by '**Key', we first convert all Valid Headers to '#### Key'
                    // A valid header is one that starts on a new line.
                    const sectionKeys = [
                        // Old
                        '三维理解', '本质动作', '关键洞察', '深度解析', '应用场景', '错误纠正', '对比分析', '本质', '场景比喻',
                        // New
                        '视觉本源', '感官本源', '物理本源', '空间/逻辑图式',
                        '逻辑演化', '概念图式', '认知标尺', '功能演化', '抽象映射',
                        '动作维度', '认知差异', '逻辑投射', '关键辨析',
                        '地道场景', '地道搭配',
                        '词性转换',
                        '一言蔽之'
                    ];
                    const keyPattern = sectionKeys.join('|').replace(/\//g, '\\/'); // Escape slashes for regex
                    // Regex: Start of line/chunk, optional MD chars, Key, optional MD chars/colons
                    // We use replaceAll to normalize headers BEFORE splitting
                    // UPDATED: Now supports space-separated markers like '* *' or '# #'
                    const headerRegexGlobal = new RegExp('(^|\\n)\\s*(?:[*#]\\s*)*(' + keyPattern + ')(?:\\s*[*#：:])*\\s*', 'g');
                    rawMarkdown = rawMarkdown.replace(headerRegexGlobal, '$1#### $2\n\n');
                    
                    // We want to split before these sections
                    // NOW we only need to look for '#### Key' because we normalized them above!
                    const sections = [
                        '### ', // Keep splitting main title if present
                        // Old
                        '#### 三维理解', '#### 本质动作', '#### 关键洞察', '#### 场景比喻', '#### 深度解析', '#### 应用场景', '#### 错误纠正', '#### 对比分析', '#### 本质',
                        // New
                        '#### 视觉本源', '#### 感官本源', '#### 物理本源', '#### 空间/逻辑图式',
                        '#### 逻辑演化', '#### 概念图式', '#### 认知标尺', '#### 功能演化', '#### 抽象映射',
                        '#### 动作维度', '#### 认知差异', '#### 逻辑投射', '#### 关键辨析',
                        '#### 地道场景', '#### 地道搭配',
                        '#### 词性转换',
                        '#### 一言蔽之'
                    ];

                    sections.forEach(sec => {
                        // Replace only the first occurrence or all? All is safer for robustness but structure implies order.
                        // We use global replace to catch them all.
                        // We need to escape special regex chars in 'sec' if we used regex, but here we can use split/join
                        // or replaceAll if supported. Let's use split/join for safety.
                        rawMarkdown = rawMarkdown.split(sec).join(SEPARATOR + sec);
                    });

                    // Remove the very first separator if it exists (empty first card)
                    if (rawMarkdown.startsWith(SEPARATOR)) {
                        rawMarkdown = rawMarkdown.substring(SEPARATOR.length);
                    }

                    const chunks = rawMarkdown.split(SEPARATOR).filter(c => c.trim().length > 10); // Filter out noise
                    
                    let cards = [];
                    let firstCardExtracted = false;

                    // Clear previous cards NOW, just before rendering new ones
                    // This ensures the blur effect stays until the last moment
                    Array.from(outputContainer.children).forEach(child => {
                        if (child.id !== 'progressContainer') child.remove();
                    });

                    chunks.forEach((chunk, chunkIndex) => {
                        const card = document.createElement('div');
                        // Make result cards interactive but ensure they don't hijack clicks from children
                        // We use 'group' to help with child interactions if needed
                        card.className = 'result-card rounded-xl overflow-hidden shadow-sm transition-all duration-200';
                        
                        // Clean up Markdown artifacts BEFORE rendering
                        // 1. Fix broken headers: '# # #' -> '###'
                        chunk = chunk.replace(/(?:^|\n)\s*#\s+#\s+#/g, '\n###');
                        chunk = chunk.replace(/(?:^|\n)\s*##\s+#/g, '\n###');
                        
                        // 2. Fix broken bold: '* *' -> '**'
                        chunk = chunk.replace(/\*\s+\*/g, '**');
                        
                        // 2b. Fix space-padded bold: '** text **' -> '**text**'
                        chunk = chunk.replace(/\*\*\s+(.*?)\s+\*\*/g, '**$1**');
                        
                        // 2c. Fix Vocabulary Adhesion: Ensure spaces around bold tags if adjacent to letters
                        // This helps 'marked' parse bold correctly and prevents words from sticking together.
                        // e.g. "agreed**with**me" -> "agreed **with** me"
                        chunk = chunk.replace(/([a-zA-Z])\*\*/g, '$1 **');
                        chunk = chunk.replace(/\*\*([a-zA-Z])/g, '** $1');
                        
                        // 3. Specific cleanup and normalization for our known section keys
                        // Goal: Convert various header formats (**Key**, ### Key, etc.) into uniform #### Key
                        // This removes the Markdown artifacts (*, #, :) from display and ensures consistent block styling.
                        // MOVED UP BEFORE FORCE BOLD to ensure headers are processed as blocks first.
                        const chunkSectionKeys = [
                            // Old
                            '三维理解', '本质动作', '关键洞察', '深度解析', '应用场景', '错误纠正', '对比分析', '本质', '场景比喻',
                            // New
                            '视觉本源', '感官本源', '物理本源', '空间/逻辑图式',
                            '逻辑演化', '概念图式', '认知标尺', '功能演化', '抽象映射',
                            '动作维度', '认知差异', '逻辑投射', '关键辨析',
                            '地道场景', '地道搭配',
                            '词性转换',
                            '一言蔽之'
                        ];
                        const chunkKeyPattern = chunkSectionKeys.join('|').replace(/\//g, '\\/');
                        // Regex: Start of line/chunk, optional MD chars, Key, optional MD chars/colons
                        // Ensure we have double newline after header for clean separation
                        const headerRegex = new RegExp('(^|\\n)\\s*[*#]*\\s*(' + chunkKeyPattern + ')[*#：:]*\\s*', 'g');
                        chunk = chunk.replace(headerRegex, '$1#### $2\n\n');

                        // 4. FORCE BOLD: Convert **text** to token manually
                        // This ensures that even if marked fails to parse it (e.g. inside words), we force it.
                        // We use a non-greedy match for content.
                        const BOLD_START = '@@BOLD_START@@';
                        const BOLD_END = '@@BOLD_END@@';
                        chunk = chunk.replace(/\*\*([^*]+?)\*\*/g, `${BOLD_START}$1${BOLD_END}`);
                        
                        // 5. Fix List Items: 
                        // 5a. Ensure space after hyphen ('-Item' -> '- Item')
                        chunk = chunk.replace(/(^|\n)\s*-(?=[^ \t\n])/g, '$1- ');
                        
                        // 5b. Ensure Lists are preceded by a newline so marked parses them as lists
                        // If a line starts with "- " and the previous line text (not newline), add a newline.
                        chunk = chunk.replace(/([^\n])\n\s*- /g, '$1\n\n- ');

                        // Render Markdown
                        let html = marked.parse(chunk);
                        
                        // RESTORE BOLD: Replace tokens with actual strong tags
                        html = html.replace(/@@BOLD_START@@/g, '<strong>').replace(/@@BOLD_END@@/g, '</strong>');
                        
                        // Structure the card into two parts: Sticky Header and Scrollable Content
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = html;
                        
                        const header = tempDiv.querySelector('h4, h3');
                        let contentWrapper;
                        
                        // Style and append header if exists
                        if (header) {
                            const headerText = header.innerText.trim();
                            const normalizedHeaderText = headerText.replace(/\*/g, '').replace(/\s+/g, '');
                            
                            // Remove header from tempDiv so it doesn't appear in contentWrapper
                            header.remove();
                            
                            // Special case: Essence (IN A NUTSHELL)
                            if ((normalizedHeaderText.startsWith('本质') && !normalizedHeaderText.includes('动作')) || normalizedHeaderText.includes('一言蔽之')) {
                                // Create a temporary content wrapper for essence extraction
                                const essenceContentWrapper = document.createElement('div');
                                essenceContentWrapper.innerHTML = tempDiv.innerHTML;

                                // Clean up content for essence card (remove P tags, convert strong to themed span)
                                let cleanContent = essenceContentWrapper.innerHTML
                                    .replace(/<p>/g, '').replace(/<\/p>/g, '')
                                    .replace(/<strong>/g, '<span class="text-blue-600/90 font-bold">').replace(/<\/strong>/g, '</span>')
                                    .replace(/\*\*/g, '') // Remove remaining markdown bold markers
                                    .trim();
                                
                                // Final check to remove any trailing asterisks left over
                                cleanContent = cleanContent.replace(/\*+$/, '');

                                // User Request: Hide original word if it starts the essence summary
                                if (verb) {
                                    try {
                                        const escapedVerb = verb.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                                        // Improved Regex: Handles HTML tags (like bold/spans) wrapping the word
                                        // Matches: Start -> Optional HTML tags -> Quotes? -> Word (Boundary) -> Quotes? -> Optional HTML tags -> Separators
                                        const regex = new RegExp(`^(\\s*<[^>]+>\\s*)*["'“‘]?\\s*\\b${escapedVerb}\\b\\s*["'”’]?(\\s*<[^>]+>\\s*)*[:：,.-]?\\s*`, 'i');
                                        cleanContent = cleanContent.replace(regex, '');
                                        
                                        // Secondary cleanup: If the removal left a dangling "is" or "means" at start, capitalize it?
                                        // For now, just ensure we trim again.
                                        cleanContent = cleanContent.trim();
                                    } catch (e) {
                                        console.warn('Regex replacement failed', e);
                                    }
                                }

                                let essenceHtml = '';
                                if (isReviewMode) {
                                    essenceHtml = `
                                        <div id="spellingContainer" class="neumorphic-inset rounded-2xl px-4 py-3 text-center border border-white/40 bg-white/10 backdrop-blur-sm shadow-inner relative overflow-hidden group">
                                            <div class="flex items-center justify-center gap-2 mb-2">
                                                <div class="h-[1px] w-8 bg-gradient-to-r from-transparent to-gray-400/50"></div>
                                                <h4 class="text-blue-500/80 font-black text-[10px] uppercase tracking-[0.2em] italic">SPELLING TEST</h4>
                                                <div class="h-[1px] w-8 bg-gradient-to-l from-transparent to-gray-400/50"></div>
                                            </div>
                                            
                                            <!-- Prompt (Translation) -->
                                            <div class="text-gray-700 text-[13.5px] leading-relaxed font-semibold italic px-4 mb-3 relative z-10">
                                                ${cleanContent}
                                            </div>

                                            <!-- Input Area -->
                                            <div class="relative max-w-xs mx-auto mb-1.5 flex gap-2">
                                                <div class="relative flex-1">
                                                    <input type="text" id="spellingInput" 
                                                        class="w-full bg-[#e0e5ec] rounded-xl px-4 py-2.5 text-center text-lg font-bold text-gray-700 shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-400/50 transition-all placeholder-gray-400/50"
                                                        placeholder="Type the word..."
                                                        autofocus
                                                        onkeydown="if(event.key==='Enter') checkSpelling(this.value)">
                                                </div>
                                                <button onclick="checkSpelling(document.getElementById('spellingInput').value)"
                                                    class="neumorphic-btn w-11 h-11 rounded-xl text-blue-500 flex items-center justify-center transition-all shrink-0">
                                                    <i class="fas fa-paper-plane"></i>
                                                </button>
                                            </div>
                                            <div id="spellingFeedback" class="text-[10px] font-bold h-3 transition-all opacity-0"></div>
                                        </div>
                                    `;
                                } else {
                                    essenceHtml = `
                                        <div class="verb-card-block neumorphic-inset rounded-2xl px-4 py-3 text-center border border-white/40 bg-white/10 backdrop-blur-sm shadow-inner relative overflow-hidden group transition-all duration-200">
                                            <!-- Decorative Quotes -->
                                            <div class="absolute left-2 top-2 text-blue-400/10 text-4xl -rotate-12">
                                                <i class="fas fa-quote-left"></i>
                                            </div>
                                            <div class="absolute right-2 bottom-2 text-blue-400/10 text-4xl -rotate-12 transition-transform group-hover:scale-110">
                                                <i class="fas fa-quote-right"></i>
                                            </div>

                                            <div class="flex items-center justify-center gap-2 mb-2">
                                                <div class="h-[1px] w-8 bg-gradient-to-r from-transparent to-gray-400/50"></div>
                                                <h4 class="text-blue-500/80 font-black text-[10px] uppercase tracking-[0.2em] italic">IN A NUTSHELL</h4>
                                                <div class="h-[1px] w-8 bg-gradient-to-l from-transparent to-gray-400/50"></div>
                                            </div>
                                            <div class="text-gray-700 text-[13.5px] leading-relaxed font-semibold italic px-4 relative z-10">
                                                ${cleanContent}
                                            </div>
                                        </div>
                                    `;
                                }

                                if (essenceContainer) {
                                    const essenceWrapper = document.getElementById('essenceContentWrapper');
                                    if (essenceWrapper) {
                                        essenceWrapper.innerHTML = essenceHtml;
                                        // Auto-focus the input if it exists
                                        setTimeout(() => {
                                            const input = document.getElementById('spellingInput');
                                            if (input) input.focus();
                                        }, 100);
                                    }
                                    essenceContainer.classList.remove('hidden');
                                }
                                return;
                            }

                            // 1. Define Base Style (Layout & Typography)
                            // Use black font and refined spacing for a more authoritative exam look
                            const baseLayout = "text-xl font-black flex items-center pt-4 pb-2 px-4 mb-0 tracking-tight";
                            
                            // 2. Define Default Color
                            let colorStyle = "text-gray-700"; 
                            let borderStyle = "bg-gray-400";
                            
                            // 3. Apply Semantic Coloring (Refined professional palette)
                            if (normalizedHeaderText.includes('三维理解') || normalizedHeaderText.includes('本质动作') || 
                                normalizedHeaderText.includes('视觉本源') || normalizedHeaderText.includes('感官本源') || normalizedHeaderText.includes('物理本源') || normalizedHeaderText.includes('空间/逻辑图式')) {
                                colorStyle = "text-blue-700"; borderStyle = "bg-blue-600 shadow-[0_0_10px_rgba(37,99,235,0.4)]";
                            } 
                            else if (normalizedHeaderText.includes('关键洞察') || normalizedHeaderText.includes('场景比喻') || 
                                     normalizedHeaderText.includes('逻辑演化') || normalizedHeaderText.includes('概念图式') || normalizedHeaderText.includes('认知标尺') || normalizedHeaderText.includes('功能演化') || normalizedHeaderText.includes('抽象映射')) {
                                colorStyle = "text-purple-700"; borderStyle = "bg-purple-600 shadow-[0_0_10px_rgba(147,51,234,0.4)]";
                            } 
                            else if (normalizedHeaderText.includes('深度解析') || normalizedHeaderText.includes('动作维度') || 
                                     normalizedHeaderText.includes('认知差异') || normalizedHeaderText.includes('逻辑投射') || normalizedHeaderText.includes('关键辨析') || normalizedHeaderText.includes('对比分析')) {
                                colorStyle = "text-indigo-700"; borderStyle = "bg-indigo-600 shadow-[0_0_10px_rgba(79,70,229,0.4)]";
                            } 
                            else if (normalizedHeaderText.includes('应用场景') || normalizedHeaderText.includes('地道场景') || normalizedHeaderText.includes('地道搭配')) {
                                colorStyle = "text-green-700"; borderStyle = "bg-green-600 shadow-[0_0_10px_rgba(22,163,74,0.4)]";
                            } 
                            else if (normalizedHeaderText.includes('词性转换')) {
                                colorStyle = "text-teal-700"; borderStyle = "bg-teal-600 shadow-[0_0_10px_rgba(13,148,136,0.4)]";
                            }
                            else if (normalizedHeaderText.includes('错误纠正')) {
                                colorStyle = "text-red-600"; borderStyle = "bg-red-600 shadow-[0_0_10px_rgba(220,38,38,0.4)]";
                            } 
                            else if (normalizedHeaderText.includes('对比分析')) {
                                colorStyle = "text-orange-600"; borderStyle = "bg-orange-500 shadow-[0_0_10px_rgba(249,115,22,0.4)]";
                            }

                            header.className = `${baseLayout} ${colorStyle} verb-card-block rounded-lg transition-all duration-200`;
                            header.innerHTML = `<span class="w-1.5 h-6 ${borderStyle} rounded-full mr-3 shrink-0"></span><span>${headerText}</span>`;
                            card.appendChild(header);
                            
                            const divider = document.createElement('div');
                            divider.className = "mx-4 border-b border-gray-300/40";
                            card.appendChild(divider);
                        }
                        
                        // Always create content wrapper (common to both branches)
                        contentWrapper = document.createElement('div');
                        contentWrapper.className = "flex-1 overflow-y-auto px-4 py-4 hide-scrollbar overscroll-contain";
                        
                        // Clean up remaining headers in tempDiv to prevent artifacts like empty <h1>
                        const leftoverHeaders = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6');
                        leftoverHeaders.forEach(h => {
                            if (h.innerText.trim() === '') h.remove();
                            else h.className = "text-lg font-black text-gray-800 mt-4 mb-2 border-l-4 border-gray-200 pl-3";
                        });

                        contentWrapper.innerHTML = tempDiv.innerHTML;
                        card.appendChild(contentWrapper);

                        // Unify text styles for all content elements
                        const contentElements = contentWrapper.querySelectorAll('ul, ol, p, li, div');
                        contentElements.forEach(el => {
                                const baseText = "text-gray-700 text-[15.5px] leading-[1.65] text-justify font-serif"; // Using serif for exam feel
                                if (el.tagName === 'UL' || el.tagName === 'OL') {
                                    el.className = "space-y-2.5 mb-4";
                                } else if (el.tagName === 'LI') {
                                    el.className = `list-disc ml-5 pl-2 ${baseText}`;
                                    // Make list items interactive
                                    el.classList.add('verb-card-block', 'rounded-lg', 'p-2', 'transition-all', 'duration-200');
                                } else if (el.tagName === 'P') {
                                    el.className = `mb-3 ${baseText}`;
                                    // Make paragraphs interactive
                                    el.classList.add('verb-card-block', 'rounded-lg', 'p-2', 'transition-all', 'duration-200');
                                } else if (el.tagName === 'DIV' && el.parentElement === contentWrapper) {
                                    // Make direct div children interactive
                                    el.classList.add('verb-card-block', 'rounded-lg', 'p-2', 'transition-all', 'duration-200');
                                }
                        });
                        
                        // No post-processing needed here as we did it inside the if/else block above

                        const text = contentWrapper.innerText;
                        
                        // H3 Title Card (The Verb Name)
                        // If this is the FIRST card and it contains the title (H3), we extract it to the modal header
                        // and DO NOT display it as a card.
                        const h3 = header && header.tagName === 'H3' ? header : null;
                        if (h3 && chunkIndex === 0 && !firstCardExtracted) {
                            // Skip adding this card to the grid
                            firstCardExtracted = true;
                            return; 
                        } else if (h3) {
                            // If H3 appears later (unlikely but possible), style it
                            h3.className = "text-xl font-bold text-blue-800 p-4 border-b pb-2";
                        }
                        
                        outputContainer.appendChild(card);
                        cards.push(card);
                    });
                    
                    // 5. Vertical Flip Logic Initialization
                    if (cards.length > 0) {
                        currentCardIndex = 0;
                        
                        // Touch handling for mobile flip
                        let touchStartY = 0;
                        let touchEndY = 0;
                        const swipeThreshold = 50; // Minimum distance for swipe

                        outputContainer.ontouchstart = (e) => {
                            touchStartY = e.touches[0].clientY;
                        };

                        outputContainer.ontouchend = (e) => {
                            touchEndY = e.changedTouches[0].clientY;
                            handleSwipe();
                        };

                        const handleSwipe = () => {
                            const activeCard = outputContainer.children[currentCardIndex];
                            if (!activeCard) return;

                            const scrollableContent = activeCard.querySelector('.flex-1.overflow-y-auto');
                            if (!scrollableContent) {
                                // No scrollable content, basic swipe
                                evaluateSwipe();
                                return;
                            }

                            const isScrollable = scrollableContent.scrollHeight > scrollableContent.clientHeight;
                            const distance = touchStartY - touchEndY; // Positive = Swipe Up (Scroll Down)

                            if (distance > 0) { 
                                // Swiping Up (Trying to go down)
                                if (isScrollable) {
                                    const distanceToBottom = scrollableContent.scrollHeight - (scrollableContent.scrollTop + scrollableContent.clientHeight);
                                    if (distanceToBottom <= 5 && distance > swipeThreshold) {
                                        switchCard('down');
                                    }
                                } else if (distance > swipeThreshold) {
                                    switchCard('down');
                                }
                            } else {
                                // Swiping Down (Trying to go up)
                                if (isScrollable) {
                                    if (scrollableContent.scrollTop <= 0 && Math.abs(distance) > swipeThreshold) {
                                        switchCard('up');
                                    }
                                } else if (Math.abs(distance) > swipeThreshold) {
                                    switchCard('up');
                                }
                            }
                        };

                        const evaluateSwipe = () => {
                            const distance = touchStartY - touchEndY;
                            if (Math.abs(distance) < swipeThreshold) return;
                            
                            if (distance > 0) {
                                // Swipe Up -> Next Card
                                switchCard('down');
                            } else {
                                // Swipe Down -> Prev Card
                                switchCard('up');
                            }
                        };
                    
                        // Add wheel listener for scrolling
                    // Only flip cards if we hit the top or bottom of the scrollable content
                    outputContainer.onwheel = (e) => {
                        const activeCard = outputContainer.children[currentCardIndex];
                        if (!activeCard) return;

                        // Find the scrollable content wrapper inside the card
                        const scrollableContent = activeCard.querySelector('.flex-1.overflow-y-auto');
                        if (!scrollableContent) {
                            // If no wrapper (unlikely now), fall back to basic switch
                            e.preventDefault();
                            switchCard(e.deltaY > 0 ? 'down' : 'up');
                            return;
                        }

                        // Check if content is scrollable
                        const isScrollable = scrollableContent.scrollHeight > scrollableContent.clientHeight;
                        
                        if (e.deltaY > 0) {
                            // Scrolling Down
                            if (isScrollable) {
                                // Calculate distance to bottom
                                const distanceToBottom = scrollableContent.scrollHeight - (scrollableContent.scrollTop + scrollableContent.clientHeight);
                                
                                if (distanceToBottom <= 5) { // Increased threshold slightly for better reliability
                                    // At bottom, switch to next card
                                    e.preventDefault();
                                    switchCard('down');
                                }
                                // Else: let native scroll happen inside scrollableContent
                            } else {
                                // Not scrollable, switch card
                                e.preventDefault();
                                switchCard('down');
                            }
                        } else {
                            // Scrolling Up
                            if (isScrollable) {
                                if (scrollableContent.scrollTop <= 0) {
                                    // At top, switch to prev card
                                    e.preventDefault();
                                    switchCard('up');
                                }
                                // Else: let native scroll happen
                            } else {
                                // Not scrollable, switch card
                                e.preventDefault();
                                switchCard('up');
                            }
                        }
                    };
                    
                    // Add keyboard listener
                    document.onkeydown = (e) => {
                        if (modal.classList.contains('active')) {
                            if (e.key === 'ArrowUp') {
                                e.preventDefault(); 
                                switchCard('up');
                            }
                            if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                switchCard('down');
                            }
                        }
                    };
                } else {
                    outputContainer.onwheel = null;
                    document.onkeydown = null;
                }

                // Initial Card State
                cards.forEach((card, i) => {
                    // Clear old classes just in case
                    card.classList.remove('active', 'prev', 'next', 'next-2', 'show');
                    
                    if (i === 0) {
                        card.classList.add('active');
                    } else if (i === 1) {
                        card.classList.add('next');
                    } else {
                        card.classList.add('next-2');
                    }
                });
                
            } else {
                    // Clear previous content on error
                    Array.from(outputContainer.children).forEach(child => {
                        if (child.id !== 'progressContainer') child.remove();
                    });
                    const errCard = document.createElement('div');
                    errCard.className = "result-card show text-red-500 font-bold mx-auto";
                    errCard.innerText = `Error: ${data.detail || data.result}`;
                    outputContainer.appendChild(errCard);
                }

            } catch (error) {
                clearInterval(progressInterval);
                if (analyzeController === currentController) {
                    analyzeController = null;
                }
                
                // If the request was aborted, just return silently
                if (error.name === 'AbortError') {
                    console.log('Analysis request aborted');
                    return;
                }

                // Clear previous content on error
                Array.from(outputContainer.children).forEach(child => {
                    if (child.id !== 'progressContainer') child.remove();
                });
                const errCard = document.createElement('div');
                errCard.className = "result-card show text-red-500 font-bold mx-auto";
                errCard.innerText = `Network Error: ${error.message}`;
                outputContainer.appendChild(errCard);
            } finally {
                if (progressContainer) progressContainer.classList.add('hidden');
            }
        }
        async function refreshExplanation() {
            const verb = modalTitle.innerText;
            if (verb) {
                await openRefreshConfirmModal(verb, () => {
                    // Force re-open the word modal to show progress overlay
                    openVerb(verb, false, true); // Force refresh
                });
            }
        }

        async function refreshFromCard(event, verb) {
            event.stopPropagation();
            await openRefreshConfirmModal(verb, () => {
                // Open modal and start refreshing immediately
                openVerb(verb, false, true); // Force refresh
            });
        }

        // Confirmation Modal Logic (Refresh Specific)
        const refreshConfirmModal = document.getElementById('refreshConfirmModal');
        const confirmVerbSpan = document.getElementById('confirmVerb');
        const confirmRefreshBtn = document.getElementById('confirmRefreshBtn');
        const apiCheckStatus = document.getElementById('apiCheckStatus');

        async function openRefreshConfirmModal(verb, onConfirm) {
            confirmVerbSpan.innerText = verb;
            
            // Check API settings
            let settings = {};
            try {
                const res = await fetch('/api/settings');
                if (res.ok) {
                    settings = await res.json();
                }
            } catch (e) {
                console.error("Failed to fetch settings from server, falling back to local storage", e);
                settings = JSON.parse(localStorage.getItem('app_settings') || '{}');
            }
            
            const hasApiKey = settings.openai_api_key && settings.openai_api_key.trim().length > 0;
            const hasBaseUrl = settings.openai_base_url && settings.openai_base_url.trim().length > 0;
            const hasModel = settings.openai_model && settings.openai_model.trim().length > 0;
            
            // Note: Settings for the explain_verbs app use 'openai_api_key', 'openai_base_url', 'openai_model'
            // instead of 'api_key', 'base_url', 'model' used in other contexts.
            
            const isApiValid = hasApiKey && hasBaseUrl && hasModel;

            if (isApiValid) {
                apiCheckStatus.className = "text-xs text-amber-600 flex items-center gap-2";
                apiCheckStatus.innerHTML = `<i class="fas fa-exclamation-triangle"></i> This will consume AI tokens.`;
                confirmRefreshBtn.disabled = false;
                confirmRefreshBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                confirmRefreshBtn.classList.add('text-blue-500');
                confirmRefreshBtn.style.pointerEvents = 'auto';
            } else {
                apiCheckStatus.className = "text-xs text-red-500 flex items-center gap-2 font-medium";
                apiCheckStatus.innerHTML = `<i class="fas fa-times-circle"></i> API not configured. Check settings.`;
                confirmRefreshBtn.disabled = true;
                confirmRefreshBtn.classList.add('opacity-50', 'cursor-not-allowed');
                confirmRefreshBtn.classList.remove('text-blue-500');
                
                // Extra check for hidden classes that might prevent clicking
                confirmRefreshBtn.style.pointerEvents = 'none';
            }

            pushModalState(closeRefreshConfirmModal);
            refreshConfirmModal.classList.remove('hidden');
            // Trigger reflow for transition
            void refreshConfirmModal.offsetWidth;
            refreshConfirmModal.classList.remove('opacity-0');
            refreshConfirmModal.querySelector('div').classList.remove('scale-95');
            refreshConfirmModal.querySelector('div').classList.add('scale-100');

            // Set up confirm action
            confirmRefreshBtn.onclick = () => {
                closeRefreshConfirmModal();
                // Ensure the details modal opens/stays open
                if (typeof onConfirm === 'function') {
                    // Small delay to let history.back() from closeRefreshConfirmModal() settle
                    setTimeout(() => {
                        onConfirm();
                    }, 50);
                }
            };
        }

        function closeRefreshConfirmModal(fromPopState = false) {
            if (fromPopState !== true) {
                // const idx = modalStack.indexOf(closeRefreshConfirmModal);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            refreshConfirmModal.classList.add('opacity-0');
            refreshConfirmModal.querySelector('div').classList.remove('scale-100');
            refreshConfirmModal.querySelector('div').classList.add('scale-95');
            
            setTimeout(() => {
                refreshConfirmModal.classList.add('hidden');
                confirmRefreshBtn.onclick = null; // Clean up
            }, 300);
        }
        // Auto Image Generation Queue Logic
        function addToQueue(verb) {
            // Avoid duplicates in queue
            if (imageQueue.includes(verb)) return;
            
            // If already processed locally
            const v = allVerbs.find(v => v['单词'] === verb);
            if (v && v.image_url) return;
            
            imageQueue.push(verb);
            processQueue();
        }

        async function processQueue() {
            if (isQueueProcessing || imageQueue.length === 0) return;
            isQueueProcessing = true;
            
            // Batch processing: take up to 10 verbs
            const batch = imageQueue.splice(0, 10);
            const verbsStr = batch.join(',');
            
            try {
                // Call API to generate images (mode=single, refresh=false)
                // Use a separate AbortController for images if needed, but for now simple fetch
                const res = await fetch('/api/explain', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        verbs: verbsStr,
                        mode: 'single',
                        refresh: false,
                        only_images: true
                    })
                });
                
                if (res.ok) {
                    const data = await res.json();
                    const settings = JSON.parse(localStorage.getItem('app_settings') || '{}');
                    const isNoneProvider = settings.image_provider === 'none';
                    
                    // Process results for each verb in batch
                    batch.forEach(verb => {
                        // Update local model - always mark as cached if API call succeeded
                        const vIndex = allVerbs.findIndex(v => v['单词'] === verb);
                        if (vIndex !== -1) {
                            allVerbs[vIndex].has_cache = true; 
                            if (data.images && data.images[verb]) {
                                allVerbs[vIndex].image_url = data.images[verb];
                            }
                        }
                        
                        // Update UI
                        updateCardWithImage(verb);
                    });
                }
            } catch (e) {
                console.error(`Auto-gen image batch failed:`, e);
            } finally {
                isQueueProcessing = false;
                // Minimal delay to process next batch quickly
                setTimeout(processQueue, 50);
            }
        }
        
        function updateCardWithImage(verb) {
            const card = document.getElementById('verb-card-' + verb);
            if (!card) return;
            
            const settings = JSON.parse(localStorage.getItem('app_settings') || '{}');
            const isNoneProvider = settings.image_provider === 'none';

            // 1. Handle Image Insertion
            if (!card.querySelector('.verb-image-container')) {
                let innerHtml = '';
                if (isNoneProvider) {
                    innerHtml = `
                    <div class="frosted-placeholder">
                        <i class="fas fa-image"></i>
                    </div>`;
                } else {
                    const proxyUrl = `/api/image/${encodeURIComponent(verb)}?t=${Date.now()}`;
                    innerHtml = `<img src="${proxyUrl}" class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110" alt="${verb}" onload="this.parentElement.classList.remove('opacity-0')" onerror="showFrostedPlaceholder(this)">`;
                }

                const newImgHtml = `
                <div class="verb-image-container w-full h-32 overflow-hidden relative shrink-0 ${isNoneProvider ? '' : 'opacity-0'} transition-opacity duration-500">
                    ${innerHtml}
                    <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>
                </div>`;
                
                card.insertAdjacentHTML('afterbegin', newImgHtml);
                
                const contentWrapper = card.querySelector('.verb-content');
                if (contentWrapper) {
                    contentWrapper.classList.remove('justify-center');
                    contentWrapper.classList.add('justify-start', 'pt-2');
                }
            }
            
            // 2. Ensure Refresh button is present
            /* Refresh button removed per user request
            if (!card.querySelector('button[onclick*="refreshFromCard"]')) {
                const refreshBtnHtml = `
                    <button 
                        onclick="refreshFromCard(event, '${verb}')"
                        class="absolute bottom-2 right-2 w-8 h-8 rounded-full bg-white/90 hover:bg-white text-blue-500 hover:text-blue-600 flex items-center justify-center opacity-100 md:opacity-0 md:group-hover:opacity-100 transition-all shadow-sm z-10 border border-blue-100"
                        title="Refresh explanation"
                    >
                        <i class="fas fa-sync-alt text-xs"></i>
                    </button>
                `;
                card.insertAdjacentHTML('beforeend', refreshBtnHtml);
            }
            */
        }
        // Vertical Card Navigation Logic
        // Modified to handle multiple cards from Markdown sections
        function drawPeekCard() {
            // No longer "drawing random" - we just show the cards sequentially
            // This function might be deprecated if we switch to simple scroll
            // But if we keep card switching logic:
            
            const outputContainer = document.getElementById('outputContainer');
            if (!outputContainer) return;
            
            // Re-query cards as they might have been re-rendered
            const cards = Array.from(outputContainer.children).filter(child => child.classList.contains('result-card'));
            if (cards.length === 0) return;

            // Ensure current index is valid
            if (currentCardIndex >= cards.length) currentCardIndex = 0;
            
            // Update classes
            updateCardClasses(cards);
        }

        function switchCard(direction) {
            const outputContainer = document.getElementById('outputContainer');
            if (!outputContainer) return;
            const cards = Array.from(outputContainer.children).filter(child => child.classList.contains('result-card'));
            
            if (cards.length === 0) return;
            
            let targetIndex = currentCardIndex;
            
            if (direction === 'next') {
                targetIndex++;
            } else if (direction === 'prev') {
                targetIndex--;
            }
            
            // Loop or clamp? Let's clamp for now, or loop if user prefers
            if (targetIndex < 0) targetIndex = 0; // Clamp start
            if (targetIndex >= cards.length) targetIndex = cards.length - 1; // Clamp end
            
            if (targetIndex !== currentCardIndex) {
                currentCardIndex = targetIndex;
                updateCardClasses(cards);
            }
        }
        
        function updateCardClasses(cards) {
            cards.forEach((card, index) => {
                // Reset all positioning classes
                card.classList.remove('active', 'prev', 'next', 'next-2');
                
                // Active card
                if (index === currentCardIndex) {
                    card.classList.add('active');
                    // Reset scroll on the newly active card content
                    const scrollable = card.querySelector('.flex-1.overflow-y-auto');
                    if (scrollable) scrollable.scrollTop = 0;
                } 
                // Previous cards (above/behind)
                else if (index < currentCardIndex) {
                    card.classList.add('prev');
                } 
                // Next card (below/preview)
                else if (index === currentCardIndex + 1) {
                    card.classList.add('next');
                } 
                // Future cards (deep stack)
                else {
                    card.classList.add('next-2');
                }
            });
            
            // Update indicator if we have one
            const indicator = document.getElementById('card-indicator');
            if (indicator) {
                indicator.textContent = `${currentCardIndex + 1} / ${cards.length}`;
            }
        }
        
    </script>
    <!-- Settings Modal (Neumorphic Full-Screen Style) -->
    <div id="settingsModal" class="fixed inset-0 z-[100] bg-[#e0e5ec] transform translate-y-full transition-transform duration-300 ease-[cubic-bezier(0.32,0.72,0,1)] flex flex-col">
        <!-- Safe Area Top Background -->
        <div class="absolute top-0 left-0 right-0 h-[var(--safe-top)] bg-[#e0e5ec] z-10"></div>
        
        <!-- Header -->
        <div class="relative z-10 bg-[#e0e5ec]/95 backdrop-blur-md border-b border-white/20 shadow-sm px-4 py-3 flex items-center justify-between shrink-0 pt-[calc(var(--safe-top)+12px)]">
            <h2 class="text-xl font-black text-gray-700 tracking-tight text-shadow-sm">Settings</h2>
            <button onclick="closeSettings()" class="w-10 h-10 flex items-center justify-center neumorphic-btn rounded-full text-gray-500 active:text-red-400 transition-colors">
                <i class="fas fa-times text-sm"></i>
            </button>
        </div>

        <!-- Scrollable Content -->
        <div class="flex-1 overflow-y-auto hide-scrollbar overscroll-contain">
            <form id="settingsForm" class="p-5 space-y-8 pb-32">
                
                <!-- Section: Analysis Mode -->
                <div class="space-y-3">
                    <h3 class="px-2 text-[10px] font-black text-gray-400 uppercase tracking-widest flex items-center gap-2">
                        <i class="fas fa-magic text-xs"></i> Analysis Logic
                    </h3>
                    <div class="neumorphic p-2 rounded-2xl space-y-2">
                        <!-- Option 1: Smart Auto -->
                        <label class="analysis-card relative flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <input type="radio" name="analysisMode" value="auto" class="peer sr-only" onchange="updateAnalysisMode(this.value)">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-blue-500 mr-3 shrink-0">
                                <i class="fas fa-bolt"></i>
                            </div>
                            <div class="flex-1">
                                <span class="text-sm font-bold text-gray-700 block">Smart Auto</span>
                                <span class="text-[10px] font-medium text-gray-400">Prefer cache, auto-generate if missing</span>
                            </div>
                            <div class="check-indicator w-5 h-5 rounded-full border-2 border-gray-300 flex items-center justify-center shadow-inner transition-colors">
                                <div class="w-2.5 h-2.5 bg-blue-500 rounded-full opacity-0 transition-opacity"></div>
                            </div>
                        </label>

                        <!-- Option 2: Strict Cache -->
                        <label class="analysis-card relative flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <input type="radio" name="analysisMode" value="cache_only" class="peer sr-only" onchange="updateAnalysisMode(this.value)">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-green-600 mr-3 shrink-0">
                                <i class="fas fa-database"></i>
                            </div>
                            <div class="flex-1">
                                <span class="text-sm font-bold text-gray-700 block">Strict Cache</span>
                                <span class="text-[10px] font-medium text-gray-400">Never generate, only use saved data</span>
                            </div>
                            <div class="check-indicator w-5 h-5 rounded-full border-2 border-gray-300 flex items-center justify-center shadow-inner transition-colors">
                                <div class="w-2.5 h-2.5 bg-blue-500 rounded-full opacity-0 transition-opacity"></div>
                            </div>
                        </label>

                        <!-- Option 3: Manual -->
                        <label class="analysis-card relative flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <input type="radio" name="analysisMode" value="manual" class="peer sr-only" onchange="updateAnalysisMode(this.value)">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-gray-400 mr-3 shrink-0">
                                <i class="fas fa-hand-pointer"></i>
                            </div>
                            <div class="flex-1">
                                <span class="text-sm font-bold text-gray-700 block">Manual Trigger</span>
                                <span class="text-[10px] font-medium text-gray-400">Always ask before generating</span>
                            </div>
                            <div class="check-indicator w-5 h-5 rounded-full border-2 border-gray-300 flex items-center justify-center shadow-inner transition-colors">
                                <div class="w-2.5 h-2.5 bg-blue-500 rounded-full opacity-0 transition-opacity"></div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Section: LLM Configuration -->
                <div class="space-y-3">
                    <h3 class="px-2 text-[10px] font-black text-gray-400 uppercase tracking-widest flex items-center gap-2">
                        <i class="fas fa-brain text-xs"></i> AI Provider
                    </h3>
                    <div class="neumorphic p-5 rounded-2xl space-y-5">
                        <!-- API Key -->
                        <div class="space-y-2">
                            <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider ml-1">OpenAI API Key</label>
                            <div class="relative">
                                <i class="fas fa-key absolute left-4 top-1/2 -translate-y-1/2 text-gray-400 text-xs"></i>
                                <input type="password" name="openai_api_key" 
                                    class="w-full neumorphic-inset bg-transparent text-gray-700 text-sm font-bold rounded-xl py-3.5 pl-10 pr-4 outline-none focus:ring-2 focus:ring-blue-400/20 transition-all placeholder-gray-400" 
                                    placeholder="sk-...">
                            </div>
                        </div>

                        <!-- Base URL -->
                        <div class="space-y-2">
                            <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider ml-1">Base URL</label>
                            <div class="relative">
                                <i class="fas fa-link absolute left-4 top-1/2 -translate-y-1/2 text-gray-400 text-xs"></i>
                                <input type="text" name="openai_base_url" 
                                    class="w-full neumorphic-inset bg-transparent text-gray-700 text-sm font-bold rounded-xl py-3.5 pl-10 pr-4 outline-none focus:ring-2 focus:ring-blue-400/20 transition-all placeholder-gray-400" 
                                    placeholder="https://api.openai.com/v1">
                            </div>
                        </div>

                        <!-- Model -->
                        <div class="space-y-2">
                            <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider ml-1">Model Name</label>
                            <div class="relative">
                                <i class="fas fa-cube absolute left-4 top-1/2 -translate-y-1/2 text-gray-400 text-xs"></i>
                                <input type="text" name="openai_model" 
                                    class="w-full neumorphic-inset bg-transparent text-gray-700 text-sm font-bold rounded-xl py-3.5 pl-10 pr-4 outline-none focus:ring-2 focus:ring-blue-400/20 transition-all placeholder-gray-400" 
                                    placeholder="gpt-3.5-turbo">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Section: Image Provider -->
                <div class="space-y-3">
                    <h3 class="px-2 text-[10px] font-black text-gray-400 uppercase tracking-widest flex items-center gap-2">
                        <i class="fas fa-image text-xs"></i> Visuals
                    </h3>
                    <div class="neumorphic p-2 rounded-2xl space-y-2">
                        <select name="image_provider" id="image_provider_select" class="hidden">
                            <option value="none">None</option>
                            <option value="dicebear">DiceBear</option>
                            <option value="pollinations">Pollinations</option>
                        </select>

                        <!-- Option: None -->
                        <div onclick="selectImageProvider('none')" id="provider-card-none" class="provider-card relative flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-gray-400 mr-3 shrink-0">
                                <i class="fas fa-ban"></i>
                            </div>
                            <div class="flex-1">
                                <span class="text-sm font-bold text-gray-700 block">No Images</span>
                                <span class="text-[10px] font-medium text-gray-400">Pure text focus</span>
                            </div>
                            <div class="check-indicator w-5 h-5 rounded-full border-2 border-gray-300 flex items-center justify-center shadow-inner transition-colors">
                                <div class="w-2.5 h-2.5 bg-blue-500 rounded-full opacity-0 transition-opacity"></div>
                            </div>
                        </div>

                        <!-- Option: DiceBear -->
                        <div onclick="selectImageProvider('dicebear')" id="provider-card-dicebear" class="provider-card relative flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-indigo-500 mr-3 shrink-0">
                                <i class="fas fa-dice"></i>
                            </div>
                            <div class="flex-1">
                                <span class="text-sm font-bold text-gray-700 block">DiceBear</span>
                                <span class="text-[10px] font-medium text-gray-400">Abstract avatars</span>
                            </div>
                            <div class="check-indicator w-5 h-5 rounded-full border-2 border-gray-300 flex items-center justify-center shadow-inner transition-colors">
                                <div class="w-2.5 h-2.5 bg-blue-500 rounded-full opacity-0 transition-opacity"></div>
                            </div>
                        </div>

                        <!-- Option: Pollinations -->
                        <div onclick="selectImageProvider('pollinations')" id="provider-card-pollinations" class="provider-card relative flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-purple-500 mr-3 shrink-0">
                                <i class="fas fa-palette"></i>
                            </div>
                            <div class="flex-1">
                                <span class="text-sm font-bold text-gray-700 block">Pollinations.ai</span>
                                <span class="text-[10px] font-medium text-gray-400">AI generated scenes</span>
                            </div>
                            <div class="check-indicator w-5 h-5 rounded-full border-2 border-gray-300 flex items-center justify-center shadow-inner transition-colors">
                                <div class="w-2.5 h-2.5 bg-blue-500 rounded-full opacity-0 transition-opacity"></div>
                            </div>
                        </div>

                        <!-- Pollinations Config (Nested) -->
                        <div id="pollinationsConfig" class="hidden p-4 mt-2 border-t border-white/20 space-y-4">
                            <div class="space-y-2">
                                <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider ml-1">Pollinations API Key</label>
                                <input type="password" name="pollinations_api_key" class="w-full neumorphic-inset bg-transparent text-gray-700 text-xs font-bold rounded-xl py-3 px-4 outline-none focus:ring-2 focus:ring-purple-400/20" placeholder="Optional">
                            </div>
                            <div class="space-y-2">
                                <label class="text-[10px] font-bold text-gray-500 uppercase tracking-wider ml-1">Model</label>
                                <input type="text" name="pollinations_model" class="w-full neumorphic-inset bg-transparent text-gray-700 text-xs font-bold rounded-xl py-3 px-4 outline-none focus:ring-2 focus:ring-purple-400/20" placeholder="flux">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Section: Data -->
                <div class="space-y-3">
                    <h3 class="px-2 text-[10px] font-black text-gray-400 uppercase tracking-widest flex items-center gap-2">
                        <i class="fas fa-database text-xs"></i> Data & Backup
                    </h3>
                    <div class="neumorphic p-2 rounded-2xl space-y-2">
                        <button type="button" onclick="exportData()" class="w-full flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-blue-500 mr-3 shrink-0">
                                <i class="fas fa-file-export"></i>
                            </div>
                            <div class="flex-1 text-left">
                                <span class="text-sm font-bold text-gray-700 block">Export Backup</span>
                                <span class="text-[10px] font-medium text-gray-400">Save progress to file</span>
                            </div>
                            <i class="fas fa-chevron-right text-gray-400 text-xs"></i>
                        </button>
                        
                        <button type="button" onclick="importData()" class="w-full flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-white/30 active:scale-[0.98]">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset flex items-center justify-center text-green-500 mr-3 shrink-0">
                                <i class="fas fa-file-import"></i>
                            </div>
                            <div class="flex-1 text-left">
                                <span class="text-sm font-bold text-gray-700 block">Restore Data</span>
                                <span class="text-[10px] font-medium text-gray-400">Load from backup file</span>
                            </div>
                            <i class="fas fa-chevron-right text-gray-400 text-xs"></i>
                        </button>
                    </div>
                </div>

                <!-- Section: Danger -->
                <div class="space-y-3 pt-4">
                    <div class="neumorphic p-2 rounded-2xl bg-red-50/10 border border-red-100/20">
                        <button type="button" onclick="closeSettings(); setTimeout(clearLearningData, 200);" class="w-full flex items-center p-3 cursor-pointer rounded-xl transition-all hover:bg-red-50 active:scale-[0.98]">
                            <div class="w-10 h-10 rounded-xl neumorphic-inset bg-red-50/50 flex items-center justify-center text-red-500 mr-3 shrink-0">
                                <i class="fas fa-trash-alt"></i>
                            </div>
                            <div class="flex-1 text-left">
                                <span class="text-sm font-bold text-red-600 block">Reset Application</span>
                                <span class="text-[10px] font-medium text-red-400/80">Clear all data and start fresh</span>
                            </div>
                        </button>
                    </div>
                    <p class="text-center text-[10px] text-gray-400 font-black uppercase tracking-widest pt-4 opacity-50">
                        NETEM Deep Vocab v1.2.0
                    </p>
                </div>
            </form>
        </div>

        <!-- Fixed Bottom Action Bar -->
        <div class="bg-[#e0e5ec] border-t border-white/20 p-4 pb-[calc(var(--safe-bottom)+16px)] shrink-0 z-20 shadow-[0_-4px_20px_rgba(163,177,198,0.2)]">
            <button type="button" id="saveSettings" class="w-full py-4 bg-blue-600 hover:bg-blue-700 active:scale-[0.98] text-white font-black text-sm uppercase tracking-widest rounded-2xl shadow-[6px_6px_12px_rgba(59,130,246,0.3),-6px_-6px_12px_rgba(255,255,255,0.2)] transition-all">
                Save Changes
            </button>
        </div>
    </div>

    <script>
        // Force Strict Context Menu Disable - SUPER STRICT
        window.addEventListener('contextmenu', function(e) {
            // Allow input/textarea long press for cursor/selection
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                // DO NOT prevent default here to allow context menu for inputs
                return;
            }
            // Block everything else
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }, { capture: true }); // Use capture phase to intercept early

        // Disable selection globally via JS as backup
        document.onselectstart = function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return true;
            // Also allow selection inside contenteditable elements
            if (e.target.isContentEditable) return true;
            return false;
        };
        
        // FIX INPUT FOCUS: Allow native behavior
        // We removed the aggressive focus() calls because they interfere with native touch-to-focus logic
        // and sometimes prevent the keyboard from appearing on mobile.
        
        // Ensure click events on inputs bubble up normally or at least aren't blocked
        window.addEventListener('touchstart', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // Explicitly allow default behavior and DO NOT manually focus
                // Manual focus() calls here fight with browser native behavior and cause flashing
                return true;
            }
        }, { passive: false }); // CHANGED to false to allow preventDefault if needed (though we don't call it)

        // Prevent other listeners from hijacking input clicks
        window.addEventListener('click', function(e) {
             if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // Don't stop propagation unless necessary, but definitely don't prevent default
                // e.target.focus(); // REMOVED manual focus here too
            }
        }, { passive: false });

        // JS-controlled Active State Logic
        (function() {
            let activeElement = null;
            let startX = 0;
            let startY = 0;
            let isScrolling = false;

            function addPressedState(e) {
                // Ignore inputs/textareas to allow normal typing/selection
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Record start position for scroll detection
                if (e.touches && e.touches[0]) {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                }
                isScrolling = false;

                // Pre-cleanup: remove any existing pressed states immediately
                removePressedState();

                // Find closest button-like element OR scrollable card
                // Expanded list to include ANY element with onclick, button role, or neumorphic class
                // REMOVED .neumorphic from selector to prevent inner decorative elements from hijacking clicks
                // ADDED .learning-insight-card to support insights interactions
                // ADDED .verb-card-block to support granular interactions within verb cards
                // ADDED .action-card-btn to support central action buttons in review/mastery
                const target = e.target.closest('button, a, .neumorphic-btn, .neumorphic-btn-sm, .neumorphic-toggle-btn, .nav-item, .verb-card, .learning-insight-card, .verb-card-block, .action-card-btn, [onclick], [role="button"]');
                if (target && !target.disabled) {
                    // EXCLUDE MODALS AND SPECIFIC CONTAINERS FROM PRESS EFFECT
                    // Check if the target is ITSELF a modal or modal content wrapper
                    if (target.id === 'verbModal' || target.id === 'learningModal' || target.id === 'settingsModal' || target.id === 'analyticsModal' || target.id === 'importConfirmModal' || target.classList.contains('fixed') || target.classList.contains('modal-content') || target.classList.contains('modal-overlay')) {
                        return;
                    }
                    
                    // Also check if target is inside a modal content area but IS the content area itself (not a button inside)
                    // The .neumorphic class is often on the modal content wrapper, which we don't want to scale
                    if (target.classList.contains('neumorphic') && !target.classList.contains('neumorphic-btn') && !target.classList.contains('neumorphic-btn-sm') && !target.classList.contains('verb-card') && !target.classList.contains('learning-insight-card') && !target.classList.contains('verb-card-block') && !target.classList.contains('action-card-btn') && !target.getAttribute('onclick') && target.tagName !== 'BUTTON' && target.tagName !== 'A') {
                         return;
                    }

                    activeElement = target;

                    // PROMOTION LOGIC: If target is a block inside a main verb card (List View), transfer press to the card itself
                    // This ensures the whole card scales as one unit, rather than just the block
                    if (target.classList.contains('verb-card-block')) {
                        const parentCard = target.closest('.verb-card');
                        if (parentCard) {
                            activeElement = parentCard;
                        }
                    }

                    // Delay adding pressed state slightly to prevent flash on quick scroll
                    // But for responsiveness, we usually want instant. Let's rely on move cancellation.
                    activeElement.classList.add('is-pressed');

                    // SPECIAL LINKING REMOVED: Since we now promote to parent card, we don't need to manually link siblings.
                    // Granular feedback for Detail View (which has no .verb-card parent) is preserved automatically.
                }
            }

            function removePressedState() {
                if (activeElement) {
                    activeElement.classList.remove('is-pressed');
                    // ONLY blur if it's NOT an input
                    if (activeElement.tagName !== 'INPUT' && activeElement.tagName !== 'TEXTAREA') {
                        try { activeElement.blur(); } catch(e){}
                    }
                    activeElement = null;
                }
                // Cleanup any strays just in case (Global cleanup)
                const pressed = document.querySelectorAll('.is-pressed');
                if (pressed.length > 0) {
                    pressed.forEach(el => {
                        el.classList.remove('is-pressed');
                        // ONLY blur if it's NOT an input
                        if (el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA') {
                            try { el.blur(); } catch(e){}
                        }
                    });
                }
                
                // Clear selection if any exists
                if (window.getSelection) {
                    try { window.getSelection().removeAllRanges(); } catch(e){}
                }
                
                // Force focus removal from active element if it's not an input
                if (document.activeElement && 
                    document.activeElement.tagName !== 'INPUT' && 
                    document.activeElement.tagName !== 'TEXTAREA') {
                    try { document.activeElement.blur(); } catch(e){}
                }
            }

            // Attach listeners to WINDOW to capture everything
            window.addEventListener('touchstart', addPressedState, { passive: false }); // CHANGED: passive: false to allow preventDefault if needed (though we return early for inputs)

            // Reset on ANY release or cancellation - ATTACH TO WINDOW
            const clearSelectionAndReset = (e) => {
                removePressedState();
                // ONLY clear selection if NOT interacting with input
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    if (window.getSelection) {
                        try { window.getSelection().removeAllRanges(); } catch(e){}
                    }
                }
            };

            window.addEventListener('touchend', clearSelectionAndReset, { capture: true });
            window.addEventListener('touchcancel', clearSelectionAndReset, { capture: true });
            window.addEventListener('mouseup', clearSelectionAndReset, { capture: true });
            document.addEventListener('mouseleave', removePressedState, { capture: true });
            window.addEventListener('dragend', removePressedState, { capture: true });
            window.addEventListener('contextmenu', removePressedState, { capture: true }); 
            window.addEventListener('scroll', removePressedState, { passive: true, capture: true });
            
            // CRITICAL FIX: Reset state on ANY movement (scrolling attempt) with threshold
            window.addEventListener('touchmove', function(e) {
                // If interacting with INPUT, allow native behavior (cursor move, selection)
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return; 
                }

                if (isScrolling) return; // Already scrolling, ignore

                if (e.touches && e.touches[0]) {
                    const moveX = e.touches[0].clientX;
                    const moveY = e.touches[0].clientY;
                    const diffX = Math.abs(moveX - startX);
                    const diffY = Math.abs(moveY - startY);

                    // Threshold of 10px to consider it a scroll/drag
                    if (diffX > 10 || diffY > 10) {
                        isScrolling = true;
                        removePressedState();
                    }
                } else {
                    // Fallback if no touches info
                    removePressedState();
                }
            }, { passive: true, capture: true });
            
            // SUPER AGGRESSIVE VIBRATION KILLER
            // Intercepts all click/auxclick events that might trigger haptics
            window.addEventListener('auxclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
            }, { capture: true });

            // Ensure anchors don't trigger context menu on long press
            document.querySelectorAll('a').forEach(a => {
                a.style.webkitTouchCallout = 'none';
                a.style.userSelect = 'none';
            });
            
            // EXPOSE RESET FUNCTION GLOBALLY
            window.globalResetPressedState = removePressedState;
            
        })();
        
        // Fix mobile active state sticky issue
        document.addEventListener('touchstart', function(e) {
            // Allow default behavior for inputs
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                // Keep passive true but maybe don't need to do anything else
            }
        }, {passive: true});
        
        // Disable context menu (legacy listener, keep as backup)
        document.addEventListener('contextmenu', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            e.preventDefault();
        });
        document.addEventListener('dragstart', e => e.preventDefault());

        function scrollToTop() {
            const content = document.querySelector('.app-content');
            if (content) {
                content.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // Add active class handling for bottom nav
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                this.classList.add('active');
            });
        });

        const settingsModal = document.getElementById('settingsModal');
        
        function openSettings() {
            // Push state first
            pushModalState(closeSettings);
            
            // Slide up animation
            requestAnimationFrame(() => {
                settingsModal.classList.remove('translate-y-full');
                settingsModal.classList.add('translate-y-0');
            });
            
            // IMMEDIATE SYNC: Load settings from localStorage directly to avoid async delay
            try {
                // 0. Visuals Priority: Check standalone key first
                const visualKey = localStorage.getItem('visuals_provider');
                if (visualKey) {
                    selectImageProvider(visualKey);
                } else {
                    const localSettings = JSON.parse(localStorage.getItem('app_settings') || '{}');
                    // 1. Restore Visuals from Object
                    if (localSettings.image_provider) {
                        selectImageProvider(localSettings.image_provider);
                    } else {
                        selectImageProvider('none');
                    }
                }
                
                const localSettings = JSON.parse(localStorage.getItem('app_settings') || '{}');
                
                // 2. Restore Analysis Mode
                if (localSettings.analysisMode) {
                    updateAnalysisModeUI(localSettings.analysisMode);
                } else if (analysisMode) {
                    updateAnalysisModeUI(analysisMode);
                }
                
                // 3. Restore Inputs
                const settingsForm = document.getElementById('settingsForm');
                if (settingsForm) {
                    Object.keys(localSettings).forEach(key => {
                        const input = settingsForm.querySelector(`[name="${key}"]`);
                        if (input && input.type !== 'radio' && input.type !== 'checkbox') {
                            input.value = localSettings[key];
                        }
                    });
                }
            } catch (e) {
                console.error("Fast settings load failed", e);
            }
            
            // Then perform full load (which might fetch updated data if we were using a real backend)
            loadSettings();
        }

        function openExcludedModal() {
            const modal = document.getElementById('excludedModal');
            if (modal) {
                pendingUnexclude.clear(); // Reset pending list on open
                pushModalState(closeExcludedModal);
                modal.classList.remove('hidden');
                renderExcludedVerbs();
            }
        }

        function closeExcludedModal(fromPopState = false) {
            const modal = document.getElementById('excludedModal');
            if (modal) {
                if (fromPopState !== true) {
                    // Manual close
                    const idx = modalStack.indexOf(closeExcludedModal);
                    if (idx > -1) modalStack.splice(idx, 1);
                    history.back();
                }
                pendingUnexclude.clear(); // Clear pending on cancel/close
                modal.classList.add('hidden');
            }
        }

        async function saveExcludedChanges() {
            if (pendingUnexclude.size === 0) {
                closeExcludedModal();
                return;
            }

            const wordsToRestore = Array.from(pendingUnexclude);
            const modal = document.getElementById('excludedModal');
            const saveBtn = modal.querySelector('button[onclick="saveExcludedChanges()"]');
            
            // UI Feedback
            const originalText = saveBtn.innerText;
            saveBtn.innerText = 'SAVING...';
            saveBtn.disabled = true;

            try {
                // Batch update (sequential but fast enough)
                for (const word of wordsToRestore) {
                    await fetch('/api/exclude', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ verb: word, exclude: false })
                    });
                    excludedVerbs.delete(word);
                }

                // Sync to LocalStorage
                localStorage.setItem('excludedVerbs', JSON.stringify([...excludedVerbs]));
                
                // Final UI Update
                updateCounts();
                applyFilters();
                updateProfileStats();
                renderExcludedVerbs();
                
                modal.classList.add('hidden');
            } catch (e) {
                console.error("Failed to save changes", e);
            } finally {
                saveBtn.innerText = originalText;
                saveBtn.disabled = false;
                pendingUnexclude.clear();
            }
        }

        function renderExcludedVerbs() {
            const modalContainer = document.getElementById('modalExcludedList');
            const badge = document.getElementById('excludedBadgeCount');
            
            if (badge) {
                badge.innerText = excludedVerbs.size;
                if (excludedVerbs.size > 0) {
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }

            if (!modalContainer) return;

            if (excludedVerbs.size === 0) {
                modalContainer.innerHTML = '<p class="text-xs text-gray-400 italic w-full text-center py-4">No excluded verbs</p>';
                return;
            }

            modalContainer.innerHTML = Array.from(excludedVerbs).sort().map(word => {
                const isPending = pendingUnexclude.has(word);
                return `
                    <div onclick="togglePendingUnexclude('${word}')" 
                         class="group flex items-center gap-2 px-3 py-1.5 rounded-xl border transition-all cursor-pointer ${isPending ? 'bg-red-50 border-red-200 opacity-50' : 'bg-white/50 border-gray-200 hover:bg-red-50 hover:border-red-100'}">
                        <span class="text-xs font-bold ${isPending ? 'text-red-400 line-through' : 'text-gray-600 group-hover:text-red-500'}">${word}</span>
                        <i class="fas ${isPending ? 'fa-undo text-red-300' : 'fa-times text-gray-400 group-hover:text-red-300'} text-[10px]"></i>
                    </div>
                `;
            }).join('');
        }

        function togglePendingUnexclude(word) {
            if (pendingUnexclude.has(word)) {
                pendingUnexclude.delete(word);
            } else {
                pendingUnexclude.add(word);
            }
            renderExcludedVerbs();
        }

        // Keep this for direct toggle from main list, but ensure it clears pending if used
        async function unexcludeVerb(word) {
            try {
                const res = await fetch('/api/exclude', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ verb: word, exclude: false })
                });
                const data = await res.json();
                if (data.status === 'success') {
                    excludedVerbs.delete(word);
                    // Sync to LocalStorage
                    localStorage.setItem('excludedVerbs', JSON.stringify([...excludedVerbs]));
                    
                    renderExcludedVerbs();
                    updateCounts();
                    applyFilters();
                    updateProfileStats(); // Sync profile stats immediately
                }
            } catch (e) {
                console.error("Failed to unexclude verb", e);
            }
        }
        
        function closeSettings(fromPopState = false) {
            if (fromPopState !== true) {
                // const idx = modalStack.indexOf(closeSettings);
                // if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            
            // Slide down animation
            requestAnimationFrame(() => {
                settingsModal.classList.remove('translate-y-0');
                settingsModal.classList.add('translate-y-full');
            });
        }
        
        // Use inline onclick or check existence to avoid TypeError
        const closeSettingsBtn = document.getElementById('closeSettings');
        if (closeSettingsBtn) {
            closeSettingsBtn.onclick = closeSettings;
        }
        
        // Handle provider change to show/hide poll config
        const settingsForm = document.getElementById('settingsForm');
        if (settingsForm) {
            const providerSelect = settingsForm.querySelector('[name="image_provider"]');
            const pollConfig = document.getElementById('pollinationsConfig');
            
            if (providerSelect && pollConfig) {
                providerSelect.onchange = () => {
                    if (providerSelect.value === 'pollinations') {
                        pollConfig.classList.remove('hidden');
                    } else {
                        pollConfig.classList.add('hidden');
                    }
                };
            }
        }
        
        function closeResetModal(fromPopState = false) {
            const modal = document.getElementById('resetModal');
            if (fromPopState !== true) {
                const idx = modalStack.indexOf(closeResetModal);
                if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        async function resetToLearn() {
            const verb = document.getElementById('modalTitle').innerText.toLowerCase();
            if (!verb) return;
            
            const modal = document.getElementById('resetModal');
            document.getElementById('resetVerbName').textContent = verb;
            
            pushModalState(closeResetModal);
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                const content = modal.querySelector('.modal-content') || modal.querySelector('div');
                if (content) {
                    content.classList.remove('scale-95');
                    content.classList.add('scale-100');
                }
            }, 10);

            const confirmBtn = document.getElementById('confirmResetBtn');
            // Remove old listeners to prevent stacking
            const newBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
            
            newBtn.onclick = async () => {
                try {
                    // Update DB status to 'learning' and reset stage
                    await db.updateProgress(verb, 1, new Date(), new Date(), 'learning', 0);
                    
                    // Update memory
                    learningStatus[verb] = {
                        stage: 1,
                        last_review: new Date().toISOString(),
                        next_review: new Date().toISOString(),
                        status: 'learning',
                        review_count: 0
                    };

                    closeResetModal();
                    closeModal();
                    
                    // Refresh lists
                    if (currentPage === 'review') {
                        await loadDueVerbs(); // Reload due verbs
                        renderReviewPage();
                    } else if (currentPage === 'mastery') {
                        renderMasteryPage();
                    }
                    
                    // Show success toast
                    const toast = document.createElement('div');
                    toast.className = 'fixed bottom-24 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full text-xs font-bold shadow-lg z-[3000] animate-fade-in';
                    toast.innerText = 'Reset to Stage 1';
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 2000);

                } catch (e) {
                    console.error("Failed to reset word", e);
                }
            };
        }

        function showResetConfirmation() {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm z-[3000] flex items-center justify-center animate-fade-in p-4';
            overlay.id = 'resetConfirmModal';
            
            // Create modal content
            overlay.innerHTML = `
                <div class="bg-white/90 backdrop-blur-md rounded-[32px] w-full max-w-sm shadow-[0_20px_50px_rgba(0,0,0,0.2)] border border-white/50 p-6 transform scale-100 opacity-100 animate-scale-in">
                    <div class="flex flex-col items-center text-center gap-4">
                        <div class="w-16 h-16 rounded-full bg-red-50 flex items-center justify-center mb-2 animate-bounce-slow">
                            <i class="fas fa-exclamation-triangle text-3xl text-red-500"></i>
                        </div>
                        
                        <h3 class="text-xl font-black text-gray-800">Reset Application?</h3>
                        
                        <p class="text-sm text-gray-500 font-medium leading-relaxed px-2">
                            This will <span class="text-red-500 font-bold">PERMANENTLY DELETE</span> all your learning progress, settings, and cached data.
                            <br><br>
                            This action cannot be undone.
                        </p>
                        
                        <div class="flex gap-3 w-full mt-4">
                            <button onclick="document.getElementById('resetConfirmModal').remove()" 
                                class="flex-1 py-3 rounded-2xl bg-gray-100 hover:bg-gray-200 text-gray-600 font-bold transition-all hover:scale-[1.02] active:scale-95">
                                Cancel
                            </button>
                            <button onclick="executeReset()" 
                                class="flex-1 py-3 rounded-2xl bg-red-500 hover:bg-red-600 text-white font-bold shadow-lg shadow-red-500/30 transition-all hover:scale-[1.02] active:scale-95">
                                Yes, Reset
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }

        async function executeReset() {
            const modal = document.getElementById('resetConfirmModal');
            if (modal) {
                // Show loading state
                const btn = modal.querySelector('button[onclick="executeReset()"]');
                if (btn) {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Resetting...';
                }
            }

            try {
                const res = await fetch('/api/ebbinghaus/clear_all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reset_settings: true })
                });
                
                const data = await res.json();
                if (data.status === 'success') {
                    // Force clear local storage items that are not handled by backend
                    localStorage.removeItem('app_settings');
                    localStorage.removeItem('visuals_provider');
                    localStorage.removeItem('excludedVerbs');
                    localStorage.removeItem('analysisMode');
                    localStorage.removeItem('autoAiAnalysis');
                    localStorage.removeItem('cacheOnlyMode');
                    localStorage.removeItem('checkin_history');
                    localStorage.removeItem('netem_learn_batch');
                    
                    // Show success state briefly before reload
                    if (modal) {
                         const content = modal.querySelector('div > div'); // Inner container
                         if (content) {
                             content.innerHTML = `
                                <div class="w-16 h-16 rounded-full bg-green-50 flex items-center justify-center mb-4">
                                    <i class="fas fa-check text-3xl text-green-500"></i>
                                </div>
                                <h3 class="text-xl font-black text-gray-800">Reset Complete</h3>
                                <p class="text-sm text-gray-500 font-medium mt-2">Reloading application...</p>
                             `;
                         }
                    }
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    alert("Reset failed: " + (data.message || "Unknown error"));
                    if (modal) modal.remove();
                }
            } catch (e) {
                console.error("Reset failed", e);
                alert("Reset failed: " + e.message);
                if (modal) modal.remove();
            }
        }

        // Deprecated: old direct call, now redirects to modal
        function clearLearningData() {
            showResetConfirmation();
        }

        async function exportData() {
            try {
                // Show loading
                const btn = document.querySelector('button[onclick="exportData()"]');
                const originalText = btn ? btn.innerHTML : '';
                if (btn) {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Exporting...';
                }

                // 1. Get excluded verbs as string
                const excludedVerbsList = Array.from(excludedVerbs).join(',');
                
                // 2. Request ZIP export
                const res = await fetch(`/api/export?excluded_verbs=${encodeURIComponent(excludedVerbsList)}`);
                
                if (!res.ok) throw new Error('Export failed');
                
                // 3. Handle Binary Response (Blob)
                const blob = await res.blob();
                const isJson = blob.type === 'application/json';
                const extension = isJson ? 'json' : 'zip';
                
                // Detect Capacitor
                if (window.Capacitor && window.Capacitor.isNative) {
                    const reader = new FileReader();
                    reader.readAsDataURL(blob);
                    reader.onloadend = async () => {
                        const base64data = reader.result; // This includes "data:application/zip;base64," prefix
                        // Clean base64 string for Filesystem plugin (it expects pure base64)
                        const pureBase64 = base64data.split(',')[1];
                        
                        const filename = `netem_backup_${new Date().toISOString().slice(0,10)}.${extension}`;
                        
                        try {
                            const { Filesystem, Directory } = Capacitor.Plugins;
                            
                            // Write file to Documents directory
                            const result = await Filesystem.writeFile({
                                path: filename,
                                data: pureBase64,
                                directory: Directory.Documents
                            });
                            
                            // Get the full URI to share
                            const fileUri = result.uri;
                            
                            // Share the file
                            const { Share } = Capacitor.Plugins;
                            
                            await Share.share({
                                title: 'NETEM Backup',
                                text: 'NETEM Deep Vocab Tools Backup',
                                url: fileUri, 
                                dialogTitle: 'Save Backup',
                                files: [fileUri] 
                            });
                            
                        } catch (fsError) {
                            console.error("Capacitor Export Error:", fsError);
                            alert("Export failed on device: " + fsError.message);
                        }
                    };
                } else {
                    // Web/Browser logic
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `netem_backup_${new Date().toISOString().slice(0,10)}.${extension}`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }
                
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = originalText;
                }
            } catch (e) {
                console.error("Export failed", e);
                alert("Export failed: " + e.message);
                // Restore button
                const btn = document.querySelector('button[onclick="exportData()"]');
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = `
                        <div class="w-10 h-10 rounded-2xl bg-white neumorphic flex items-center justify-center text-green-500 group-hover:bg-green-500 group-hover:text-white transition-all duration-300 shadow-sm">
                            <i class="fas fa-file-export text-sm"></i>
                        </div>
                        <span class="text-xs font-black uppercase tracking-widest">Export</span>
                    `;
                }
            }
        }

        function downloadBlob(blob) {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `netem_backup_${new Date().toISOString().slice(0,10)}.zip`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function closeImportConfirmModal(fromPopState = false) {
            const modal = document.getElementById('importConfirmModal');
            if (fromPopState !== true) {
                const idx = modalStack.indexOf(closeImportConfirmModal);
                if (idx > -1) modalStack.splice(idx, 1);
                history.back();
            }
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-95');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function importData() {
            // Create hidden file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.zip,.json'; 
            input.style.display = 'none';
            document.body.appendChild(input);
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) {
                    document.body.removeChild(input);
                    return;
                }
                
                const modal = document.getElementById('importConfirmModal');
                pushModalState(closeImportConfirmModal);
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.classList.remove('opacity-0');
                    modal.querySelector('div').classList.remove('scale-95');
                    modal.querySelector('div').classList.add('scale-100');
                }, 10);

                document.getElementById('confirmImportBtn').onclick = async () => {
                    closeImportConfirmModal();
                    
                    // Show loading
                    const btn = document.querySelector('button[onclick="importData()"]');
                    const originalText = btn ? btn.innerHTML : '';
                    if (btn) {
                        btn.disabled = true;
                        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Importing...';
                    }

                    try {
                        const formData = new FormData();
                        formData.append('file', file);

                        const res = await fetch('/api/import', {
                            method: 'POST',
                            body: formData // Send as FormData for file upload
                        });
                        
                        const result = await res.json();
                        
                        if (result.status === 'success') {
                            // Restore excluded verbs if returned
                            if (result.excluded_verbs) {
                                try {
                                    const verbs = result.excluded_verbs.split(',').filter(v => v);
                                    excludedVerbs = new Set(verbs);
                                    localStorage.setItem('excludedVerbs', JSON.stringify(Array.from(excludedVerbs)));
                                } catch (e) {
                                    console.warn("Failed to restore excluded verbs", e);
                                }
                            }
                            
                            // Use custom modal for success message instead of alert
                            showResetConfirmation(); // Reuse the reset confirmation modal structure but for success message
                            const resetModal = document.getElementById('resetConfirmModal');
                            if (resetModal) {
                                const content = resetModal.querySelector('div > div');
                                if (content) {
                                    content.innerHTML = `
                                        <div class="w-16 h-16 rounded-full bg-green-50 flex items-center justify-center mb-4">
                                            <i class="fas fa-check text-3xl text-green-500"></i>
                                        </div>
                                        <h3 class="text-xl font-black text-gray-800">Import Successful</h3>
                                        <p class="text-sm text-gray-500 font-medium mt-2">Reloading application...</p>
                                    `;
                                    // Remove buttons
                                    const btns = resetModal.querySelectorAll('button');
                                    btns.forEach(b => b.remove());
                                }
                            }
                            
                            setTimeout(() => window.location.reload(), 1500);
                        } else {
                            throw new Error(result.detail || result.message || "Unknown error");
                        }
                    } catch (e) {
                        console.error("Import failed", e);
                        // Show error in a custom way or fallback to alert if complex UI is overkill for error
                        alert("Import failed: " + e.message);
                        if (btn) {
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                        }
                    } finally {
                         document.body.removeChild(input);
                    }
                };
                
                // If cancelled, clean up input
                const cancelBtn = modal.querySelector('button[onclick="closeImportConfirmModal()"]');
                const originalCancel = cancelBtn.onclick;
                cancelBtn.onclick = () => {
                    document.body.removeChild(input);
                    closeImportConfirmModal();
                    // Restore original handler just in case
                    cancelBtn.onclick = originalCancel; 
                };
            };
            
            input.click();
        }

        function selectImageProvider(provider) {
            // Update UI
            document.querySelectorAll('.provider-card').forEach(card => {
                const indicator = card.querySelector('.check-indicator');
                const dot = indicator.querySelector('div');
                
                if (card.id === `provider-card-${provider}`) {
                    // Selected: Inset (pressed) look
                    card.classList.add('neumorphic-inset');
                    card.classList.remove('hover:bg-white/30');
                    
                    indicator.classList.add('border-blue-500', 'bg-blue-50/50');
                    indicator.classList.remove('border-gray-300');
                    dot.classList.remove('opacity-0');
                } else {
                    // Unselected: Flat with hover
                    card.classList.remove('neumorphic-inset');
                    card.classList.add('hover:bg-white/30');
                    
                    indicator.classList.remove('border-blue-500', 'bg-blue-50/50');
                    indicator.classList.add('border-gray-300');
                    dot.classList.add('opacity-0');
                }
            });

            // Update hidden select
            const select = document.getElementById('image_provider_select');
            if (select) {
                select.value = provider;
                // Trigger change event for Pollinations config visibility
                const pc = document.getElementById('pollinationsConfig');
                if (provider === 'pollinations') {
                    pc.classList.remove('hidden');
                    pc.classList.add('animate-fade-in');
                } else {
                    pc.classList.add('hidden');
                }
            }
        }

        function updateAnalysisMode(value) {
            analysisMode = value;
            localStorage.setItem('analysisMode', value);
            
            // Sync with old variables just in case
            if (value === 'auto') {
                localStorage.setItem('autoAiAnalysis', 'true');
                localStorage.setItem('cacheOnlyMode', 'false');
            } else if (value === 'cache_only') {
                localStorage.setItem('autoAiAnalysis', 'true');
                localStorage.setItem('cacheOnlyMode', 'true');
            } else {
                localStorage.setItem('autoAiAnalysis', 'false');
                localStorage.setItem('cacheOnlyMode', 'false');
            }
            
            // Update UI
            updateAnalysisModeVisuals();
        }
        
        function updateAnalysisModeVisuals() {
            document.querySelectorAll('.analysis-card').forEach(card => {
                const input = card.querySelector('input[type="radio"]');
                const indicator = card.querySelector('.check-indicator');
                const dot = indicator.querySelector('div');

                if (input && input.checked) {
                    card.classList.add('neumorphic-inset');
                    card.classList.remove('hover:bg-white/30');
                    
                    indicator.classList.add('border-blue-500', 'bg-blue-50/50');
                    indicator.classList.remove('border-gray-300');
                    dot.classList.remove('opacity-0');
                } else {
                    card.classList.remove('neumorphic-inset');
                    card.classList.add('hover:bg-white/30');
                    
                    indicator.classList.remove('border-blue-500', 'bg-blue-50/50');
                    indicator.classList.add('border-gray-300');
                    dot.classList.add('opacity-0');
                }
            });
        }

        function updateAnalysisModeUI(mode) {
            // Update settings modal inputs
            const radios = document.querySelectorAll('input[name="analysisMode"]');
            radios.forEach(r => {
                if (r.value === mode) r.checked = true;
            });
            updateAnalysisModeVisuals();
        }

        async function loadSettings() {
            try {
                const res = await fetch('/api/settings', {
                    signal: pageAbortController.signal
                });
                const data = await res.json();
                
                // Populate form
                const settingsForm = document.getElementById('settingsForm');
                if (settingsForm) {
                    // Load server settings
                    Object.keys(data).forEach(key => {
                        const input = settingsForm.querySelector(`[name="${key}"]`);
                        if (input) {
                            if (input.type === 'checkbox') {
                                input.checked = data[key] === true || data[key] === 'true';
                            } else {
                                input.value = data[key];
                            }
                        }
                    });
                    
                    // Initialize Custom Provider UI
                    // PRIORITY: Standalone Key > API Response > Object Key > Default
                    const standaloneVisuals = localStorage.getItem('visuals_provider');
                    
                    if (standaloneVisuals) {
                        selectImageProvider(standaloneVisuals);
                    } else if (data.image_provider) {
                        selectImageProvider(data.image_provider);
                    } else {
                        const local = JSON.parse(localStorage.getItem('app_settings') || '{}');
                        if (local.image_provider) {
                            selectImageProvider(local.image_provider);
                        } else {
                            selectImageProvider('none');
                        }
                    }
                    
                    // Load local analysisMode setting
                    updateAnalysisModeUI(analysisMode);

                    // Trigger change event
                    const providerSelect = settingsForm.querySelector('[name="image_provider"]');
                    if (providerSelect) {
                        providerSelect.dispatchEvent(new Event('change'));
                    }
                }
                
            } catch (e) {
                if (e.name === 'AbortError') return;
                console.error("Failed to load settings", e);
            }
        }
        
        async function recordReview(result) {
            // IMMEDIATE: Reset any pressed buttons
            if (window.globalResetPressedState) window.globalResetPressedState();

            const verb = document.getElementById('modalTitle').innerText.toLowerCase();
            if (!verb) return;

            try {
                const res = await fetch('/api/ebbinghaus/record', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ verb, result }),
                    signal: pageAbortController.signal
                });
                const data = await res.json();
                
                if (data.status === 'success') {
                    // Update local status
                    const isNewWord = !learningStatus[verb.toLowerCase()] || learningStatus[verb.toLowerCase()].stage === 0;
                    await loadLearningStatus();
                    
                    // Trigger daily check-in
                    autoCheckin();
                    
                    // Update the batch if we are in Learn page
                    if (currentPage === 'learn') {
                        updateSavedBatch(verb);
                        // Also update displayedVerbs locally so the card disappears on renderGrid
                        displayedVerbs = displayedVerbs.filter(v => v['单词'].toLowerCase() !== verb.toLowerCase());
                    }

                    // Update the badge in the modal IMMEDIATELY for visual feedback
                    const stageBadge = document.getElementById('modalStageBadge');
                    const updatedStatus = learningStatus[verb.toLowerCase()];
                    if (updatedStatus && stageBadge) {
                        stageBadge.innerText = `Stage ${updatedStatus.stage}${updatedStatus.status === 'mastered' ? ' (Mastered)' : ''}`;
                        stageBadge.classList.remove('hidden');
                        if (updatedStatus.status === 'mastered') {
                            stageBadge.classList.remove('bg-blue-100', 'text-blue-600');
                            stageBadge.classList.add('bg-green-100', 'text-green-600');
                        } else {
                            stageBadge.classList.remove('bg-green-100', 'text-green-600');
                            stageBadge.classList.add('bg-blue-100', 'text-blue-600');
                        }
                    }
                    
                    updateCounts();
                    
                    // Update session stats
                    sessionReviewStats.count++;
                    if (result === 'remembered') sessionReviewStats.remembered++;
                    
                    // Logic for auto-jumping to next word
                    if (currentFreq === 'review' || currentPage === 'review') {
                        // Determine which list to use for navigation
                        const sourceList = currentPage === 'review' ? reviewVerbsList : displayedVerbs;
                        
                        // Find current verb index in the source list
                        const currentIndex = sourceList.findIndex(v => v['单词'].toLowerCase() === verb);
                        
                        // Wait a bit for the toast to be seen
                        setTimeout(() => {
                            // Find next word that is due for review
                            let nextVerbToReview = null;
                            const now = new Date();
                            
                            // Start searching from currentIndex + 1
                            for (let i = currentIndex + 1; i < sourceList.length; i++) {
                                const v = sourceList[i];
                                const status = learningStatus[v['单词'].toLowerCase()];
                                if (status && new Date(status.next_review) <= now && status.status !== 'mastered') {
                                    nextVerbToReview = v['单词'];
                                    break;
                                }
                            }
                            
                            // If not found in subsequent items, search from the beginning (wrap around)
                            if (!nextVerbToReview) {
                                for (let i = 0; i < currentIndex; i++) {
                                    const v = sourceList[i];
                                    const status = learningStatus[v['单词'].toLowerCase()];
                                    if (status && new Date(status.next_review) <= now && status.status !== 'mastered') {
                                        nextVerbToReview = v['单词'];
                                        break;
                                    }
                                }
                            }

                            if (nextVerbToReview) {
                                // Reset button states before transition
                                if (window.globalResetPressedState) window.globalResetPressedState();
                                
                                // Open next word without closing modal (just switch content)
                                openVerb(nextVerbToReview, true);
                                // Re-render background UI
                                if (currentPage === 'review') renderReviewPage();
                                else renderGrid(); 
                            } else {
                                // No more words to review, close modal
                                closeModal();
                                // Reset buttons again after closing modal
                                if (window.globalResetPressedState) window.globalResetPressedState();

                                if (currentPage === 'review') {
                                    renderReviewSummary();
                                } else {
                                    renderGrid();
                                }
                            }
                        }, 800);
                    } else {
                        // Not in review mode, just close normally
                        setTimeout(() => {
                            closeModal();
                            // Reset buttons again after closing modal
                            if (window.globalResetPressedState) window.globalResetPressedState();

                            if (currentPage === 'learn') {
                                applyFilters(); // Re-filter and potentially generate new batch if empty
                            } else {
                                renderGrid(true);
                            }
                        }, 800);
                    }
                }
            } catch (e) {
                if (e.name === 'AbortError') return;
                console.error("Error recording review:", e);
            }
        }
        
        function saveSettings() {
            const saveBtn = document.getElementById('saveSettings');
            const originalText = saveBtn ? saveBtn.innerText : 'Save';
            
            if (saveBtn) {
                saveBtn.innerText = 'Saving...';
                saveBtn.disabled = true;
            }

            try {
                // 1. Load existing settings first to preserve other keys (like daily_goal)
                const currentSettings = JSON.parse(localStorage.getItem('app_settings') || '{}');
                
                // 2. Manually capture values from DOM to avoid FormData/hidden input issues
                const newSettings = { ...currentSettings };

                // Capture API Key
                const apiKeyInput = document.querySelector('input[name="openai_api_key"]');
                if (apiKeyInput) newSettings.openai_api_key = apiKeyInput.value.trim();

                // Capture Base URL
                const baseUrlInput = document.querySelector('input[name="openai_base_url"]');
                if (baseUrlInput) newSettings.openai_base_url = baseUrlInput.value.trim();

                // Capture Model
                const modelInput = document.querySelector('input[name="openai_model"]');
                if (modelInput) newSettings.openai_model = modelInput.value.trim();

                // Capture Pollinations Config
                const pollKeyInput = document.querySelector('input[name="pollinations_api_key"]');
                if (pollKeyInput) newSettings.pollinations_api_key = pollKeyInput.value.trim();

                const pollModelInput = document.querySelector('input[name="pollinations_model"]');
                if (pollModelInput) newSettings.pollinations_model = pollModelInput.value.trim();

                // Capture Analysis Mode (Radio)
                const analysisModeInput = document.querySelector('input[name="analysisMode"]:checked');
                if (analysisModeInput) {
                    newSettings.analysisMode = analysisModeInput.value;
                    // Also update legacy keys for compatibility
                    updateAnalysisMode(analysisModeInput.value);
                }

                // Capture Image Provider (Priority: Hidden Select > UI State > Default)
                // We revert to trusting the hidden select as the primary source of truth,
                // because it is explicitly updated by the selection function.
                let selectedProvider = null;
                const providerSelect = document.getElementById('image_provider_select');
                
                if (providerSelect && providerSelect.value) {
                    selectedProvider = providerSelect.value;
                }
                
                // Fallback to UI state only if select is somehow empty
                if (!selectedProvider) {
                    if (document.getElementById('provider-card-none')?.classList.contains('neumorphic-inset')) {
                        selectedProvider = 'none';
                    } else if (document.getElementById('provider-card-pollinations')?.classList.contains('neumorphic-inset')) {
                        selectedProvider = 'pollinations';
                    } else if (document.getElementById('provider-card-dicebear')?.classList.contains('neumorphic-inset')) {
                        selectedProvider = 'dicebear';
                    }
                }
                
                // Final fallback
                newSettings.image_provider = selectedProvider || 'none';

                // 3. Save merged settings to LocalStorage
                localStorage.setItem('app_settings', JSON.stringify(newSettings));
                // DUAL SAVE: Save strictly to a separate key to avoid object merging issues
                // Explicitly allow saving 'none' or any valid value
                if (newSettings.image_provider) {
                    localStorage.setItem('visuals_provider', newSettings.image_provider);
                } else {
                    // If somehow empty, default to none
                    localStorage.setItem('visuals_provider', 'none');
                }
                
                console.log("Settings saved successfully:", newSettings);

                // 4. Visual Feedback
                if (saveBtn) {
                    saveBtn.innerText = 'Saved!';
                    setTimeout(() => {
                        saveBtn.innerText = originalText;
                        saveBtn.disabled = false;
                        closeSettings();
                        // Force reload settings to apply changes immediately
                        loadSettings(); 
                    }, 500);
                } else {
                    closeSettings();
                    loadSettings();
                }
            } catch (e) {
                console.error("Save settings failed:", e);
                alert("Failed to save settings: " + e.message);
                if (saveBtn) {
                    saveBtn.innerText = originalText;
                    saveBtn.disabled = false;
                }
            }
        }

        // Attach to button if exists
        const saveBtn = document.getElementById('saveSettings');
        // Ensure we remove old listeners to prevent duplicates
        if (saveBtn) {
            saveBtn.onclick = null; 
            saveBtn.onclick = saveSettings;
        }

        // Proxy fetch to LocalAPI (only if not running on FastAPI port 8080)
        const originalFetch = window.fetch;
        window.fetch = async function(url, options) {
            let route = typeof url === 'string' ? url : url.url;
            
            // Disable proxy if running on FastAPI server (port 8080)
            const isFastApi = window.location.port === '8080' || window.location.port === '8081';
            
            if (route.startsWith('/api/') && !isFastApi) {
                // Remove query parameters for routing
                const cleanRoute = route.split('?')[0];
                
                // Special handling for DELETE /api/checkins/YYYY-MM-DD
                if (options && options.method === 'DELETE' && cleanRoute.startsWith('/api/checkins/')) {
                    const date = cleanRoute.split('/').pop();
                    const result = await LocalAPI.handle('/api/checkins/delete', { date });
                    return new Response(JSON.stringify(result), { status: 200, headers: { 'Content-Type': 'application/json' } });
                }

                let data = {};
                if (options && options.body) {
                    if (options.body instanceof FormData) {
                        const file = options.body.get('file');
                        if (file) {
                            try {
                                // IMPORTANT: For LocalAPI import, we pass the raw File object.
                                // LocalAPI.handle will process it (via JSZip).
                                // Do NOT try to parse as JSON text here, as it is a binary ZIP file.
                                data = { file: file };
                            } catch (e) {
                                console.error("Error preparing backup file:", e);
                                return new Response(JSON.stringify({ status: "error", message: "Invalid file" }), {
                                    status: 400,
                                    headers: { 'Content-Type': 'application/json' }
                                });
                            }
                        }
                    } else {
                        try {
                            data = JSON.parse(options.body);
                        } catch (e) {
                            // If not JSON, use as is (e.g. for simple strings)
                            data = options.body;
                        }
                    }
                }

                try {
                    const result = await LocalAPI.handle(cleanRoute, data);
                    return new Response(JSON.stringify(result, null, 2), {
                        status: 200,
                        headers: { 'Content-Type': 'application/json' }
                    });
                } catch (error) {
                    console.error("LocalAPI proxy error:", error);
                    return new Response(JSON.stringify({ error: error.message }), {
                        status: 500,
                        headers: { 'Content-Type': 'application/json' }
                    });
                }
            }
            return originalFetch(url, options);
        };

        // Initialize listeners
        document.addEventListener('DOMContentLoaded', async () => {
            // FORCE CLEANUP: Remove any lingering refresh buttons that might be cached in DOM
            const cleanupButtons = () => {
                document.querySelectorAll('button[onclick*="refreshFromCard"]').forEach(btn => btn.remove());
            };
            cleanupButtons();
            // Also observe for new ones just in case
            const observer = new MutationObserver((mutations) => {
                cleanupButtons();
            });
            observer.observe(document.body, { childList: true, subtree: true });

            initPullToRefresh();
            updateKaoyanCountdown();
            
            // Initialize LocalAPI
            await LocalAPI.init(originalFetch);
            
            // Initial data load
            await loadLearningStatus();
            await loadSettings();
            await loadVerbs(); // Changed from loadAllVerbs to loadVerbs

            // Handle Android Hardware Back Button
            // If Capacitor is available, listen for 'backButton' event
            if (window.Capacitor) {
                const { App } = Capacitor.Plugins;
                App.addListener('backButton', ({ canGoBack }) => {
                    // 1. Close Learning/Verb Modal if active
                    const learningModal = document.getElementById('learningModal');
                    if (learningModal && learningModal.classList.contains('active')) {
                        closeModal();
                        return;
                    }

                    // 2. Close Settings Modal if open
                    const settingsModal = document.getElementById('settingsModal');
                    if (settingsModal && settingsModal.classList.contains('translate-y-0')) {
                        closeSettings();
                        return;
                    }
                    
                    // 3. Close Excluded Modal if open
                    const excludedModal = document.getElementById('excludedModal');
                    if (excludedModal && !excludedModal.classList.contains('hidden')) {
                        closeExcludedModal();
                        return;
                    }

                    // 3.5 Close Analytics Modal if open
                    const analyticsModal = document.getElementById('analyticsModal');
                    if (analyticsModal && !analyticsModal.classList.contains('hidden')) {
                        closeAnalytics();
                        return;
                    }
                    
                    // 3.6 Close Search Modal if open
                    const searchModal = document.getElementById('searchModal');
                    if (searchModal && !searchModal.classList.contains('hidden')) {
                        closeSearchModal();
                        return;
                    }

                    // 4. Close Reset Confirmation Modal if open (dynamically appended)
                    const resetModal = document.getElementById('resetConfirmModal');
                    if (resetModal) {
                        try {
                            document.body.removeChild(resetModal);
                        } catch (e) { console.warn("Could not remove resetModal", e); }
                        return;
                    }
                    
                    // 4.1 Close Import Confirm Modal
                    const importConfirmModal = document.getElementById('importConfirmModal');
                    if (importConfirmModal && !importConfirmModal.classList.contains('hidden')) {
                        closeImportConfirmModal();
                        return;
                    }
                    
                    // 4.2 Close Clear All Modal
                    const clearAllModal = document.getElementById('clearAllModal');
                    if (clearAllModal && !clearAllModal.classList.contains('hidden')) {
                        closeClearAllModal();
                        return;
                    }

                    // 5. If on a sub-page (not Learn/Home), go back to Learn/Home
                    // Assuming 'learn' is the home page.
                    if (currentPage !== 'learn') {
                        switchPage('learn');
                        return;
                    }

                    // 6. Otherwise, minimize app (background) instead of exit
                    App.minimizeApp();
                });
            }
        });
    </script>
    <!-- Service Worker Registration -->
    <script>
        // Force unregister all old service workers to prevent stale cache issues
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    console.log('Unregistering SW:', registration);
                    registration.unregister();
                }
                // Optional: Force reload if we found and removed workers? 
                // No, just let the new one take over if we were to register it.
                // But user requested to FORCE UNREGISTER and start page.
                // So we do NOT register a new one here immediately to ensure clean slate.
                console.log('All Service Workers unregistered.');
            });
        }
    </script>
</body>
</html>
